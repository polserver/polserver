<?xml version='1.0' encoding="iso-8859-1"?>
<?xml-stylesheet type="text/xsl" href="scripttypes.xslt" ?>
<!DOCTYPE ESCRIPT SYSTEM "scripttypes.dtd">
<ESCRIPT>
<fileheader name="POL Script Types">
  <desc>This is a list of all the different script types used in the POL system. Some only pertain to specific objects, and/or specifc events, as described.</desc>
  <datemodified>12/14/2019</datemodified>
</fileheader>


<scripttype name="UseScript">
    <prototype>program usescript(character, item)</prototype>
    <parameter name="character" value="Character Ref"/>
    <parameter name="item" value="Item Ref" />
    <return>Return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a client double clicks on an item with a defined use script.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/items</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'Script' property defines the location of the double-click script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/items. Also item.usescript is writable in the same format.</todefine>
    <explain>This interactive script is called when a client double clicks on an item. This script is then attached to the character (meaning, no other script may be attached to the character until this script exits or calls Detach()).
             If the itemdesc.cfg entry also defines 'RequiresAttention 1' then using that item will cause the player to unhide. </explain>
    <explain>By default the player needs to have line-of-sight to the item. Use the 'UseRequiresLOS' property in the itemdesc.cfg entry to change this per-item template.</explain>
    <explain>By default ghosts may not use items. Use the 'GhostsCanUse' property in the itemdesc.cfg entry to change this per-item template.</explain>
    <explain>The default maximum distance away from the item to use it is 2 or the defined 'DefaultDoubleclickRange' in servspecopt.cfg. To override this, use the 'DoubleclickRange' property in the itemdesc.cfg entry to change this per-item template.</explain>
    <explain>Can be used to override the default double-click behaviors of Containers, Maps, etc.</explain>
    <explain>Doesn't work with Multis.</explain>
    <example>
use uo;
use util;
program my_example_usescript(character, item)
    PrintTextAbove(item, character.name + " used me!");
    item.color := RandomInt(50);
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedcfg>servspecopt.cfg</relatedcfg>
</scripttype>


<scripttype name="WalkOnScript">
    <prototype>program walkonscript(character, item, lastx, lasty, lastz)</prototype>
    <parameter name="character" value="Character Ref"/>
    <parameter name="item" value="Item Ref" />
    <parameter name="lastx" value="Character's previous integer world coordinate" />
    <parameter name="lasty" value="Character's previous integer world coordinate" />
    <parameter name="lastz" value="Character's previous integer world coordinate" />
    <return>Return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a character moves onto this item.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/items</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'WalkOnScript' property defines the location of the walk-on script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/items.</todefine>
    <explain>This interactive script is called when a client moves on an item (walk or teleports). This script is NOT attached to the character.</explain>
    <explain>Doesn't work with Multis.</explain>
    <example>
use uo;
use util;
program my_example_walkonscript(character, item, lastx, lasty, lastz)
    PrintTextAbove(item, "Ouch! " + character.name + ", don't step on me!");
    MoveItemToLocation( item, lastx, lasty, lastz );
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
</scripttype>


<scripttype name="ControlScript">
    <prototype>program controlscript(item)</prototype>
    <parameter name="item" value="Item Ref" />
    <return>Return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>Immediately after the item is created (includes boot-up).</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'ControlScript' property defines the location of the control script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script is called when the item is created and stays attached to the item. Usually control scripts do not exit until the item is destroyed (note, you must handle this yourself). They generally use a loop to process events or do some housecleaning after some sleeping, or wait_for_event.</explain>
    <example>
use uo;
use os;
program my_example_controlscript(item)
    RegisterForSpeechEvents(item, 5);
    var who;
    while(item) //exit loop if item is destroyed
        ev := wait_for_event(120);
        if(ev)
            who := ev.source;
            PrintTextAbove(item, who.name + " said: " + ev.text);
        endif
    endwhile
endprogram</example>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>AIScript</relatedtype>
</scripttype>


<scripttype name="CreateScript">
    <prototype>program createscript(item)</prototype>
    <parameter name="item" value="Item Ref" />
    <return>If 0, item is destroyed, else item is added to the world.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>While the item is being created (via uo.em create item functions, or by the core).</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'CreateScript' property defines the location of the create script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script is called when the item is created. Return 1 to allow the item to be created, 0 to destroy the item.</explain>
    <example>
use uo;
program my_example_createscript(item)
    if(item.x &gt;= 500 &amp;&amp; item.x &lt;= 600)
        print("Item created in illegal location");
        return 0;
    endif
    return 1;
endprogram</example>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>DestroyScript</relatedtype>
</scripttype>


<scripttype name="DestroyScript">
    <prototype>program destroyscript(item)</prototype>
    <parameter name="item" value="Item Ref" />
    <return>If 1, item is allowed to be destroyed, else it is not destroyed.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>While the item is being destroyed (UO.EM::DestroyItem() or core decay).</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'DestroyScript' property defines the location of the destroy script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script is called while the item is being destroyed. Return 1 to allow the item to be destroy, 0 to not allow destruction.</explain>
    <example>
use uo;
program my_example_destroyscript(item)
    var gm_flag := GetObjProperty(item,"GM_FLAG");
    if(gm_flag != error)
        return 0;
    else
        return 1;
    endif
endprogram</example>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
</scripttype>


<scripttype name="MethodScript">
    <prototype>exported function methodname(params,...)</prototype>
    <parameter name="item" value="Item Ref" />
    <return>core ignores return value, except for Install() see below</return>
    <schedtype>Install() Run To Completion, methods normal</schedtype>
    <def_prio>Install() critical, methods 1</def_prio>
    <whencalled>When a script calls the method for the item, i.e. item.methodname()</whencalled>
    <wherelives>In a .src file, and MUST BE in a package.</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'MethodScript' property defines the location of the create script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package.</todefine>
    <explain>Method Scripts allow new object methods to be defined, and can override built-in methods. For example, you may define a method door.wackymethod() or override door.open().</explain>
    <explain>To enable the exported functions in the script, the 'program' in the file must return 1. This is the 'Install()' program that enables the exported methods.</explain>
    <explain>The exported functions may take any number of parameters</explain>
    <explain>To instead call the built-in methods for an object, preceed the name with an underscore '_'. So if you override door.close(), use door._close() to instead call the built-in version.</explain>
    <example>
// This simple example shows how to override the door.open() method
pkg/.../door/itemdesc.cfg:
Door 0x0675
{
    xmod -1
    ymod +1
    script door
    doortype metal
    MethodScript cdoor.ecl  //note .ecl extension
}

pkg/.../door/cdoor.src:
exported function open( door )
    print( "cdoor::open(" + door.serial + ")" );
    return door._open();
endfunction

program install()
    print( "installing cdoor" );
    return 1;
endprogram</example>
    <example>
// This example shows how to define your own methods
//pkg/.../mypkg/itemdesc.cfg:
Item 0xE000
{
    //normal itemdesc.cfg entries, graphic, etc.
    Name widget
    MethodScript widget_methods.ecl
}

// pkg/.../mypkg/widget_methods.src:
program install()
    print("installing widget");
    return 1;
endprogram

exported function discombobulate(flag1, message) //pass by reference here is ok too!
    if(flag1 > 3)
        print(message);
        return 1;
    endif
    return 0;
endfunction

// So now, in another script, if 'widget' is a reference to 
// item 0xE000, call like this:
widget.discombobulate(4,"Meaningless message");</example>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
</scripttype>


<scripttype name="CanInsertScript">
    <prototype>program caninsertscript(character, container, movetype, inserttype, adding_item, existing_stack, amount_to_add)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="container" value="Container Ref" />
    <parameter name="movetype" value="integer" />
    <parameter name="inserttype" value="integer" />
    <parameter name="adding_item" value="Item Ref" />
    <parameter name="existing_stack" value="Item Ref" />
    <parameter name="amt_to_add" value="integer" />
    
    <return>If 1, item is allowed to be inserted into the container, else it is not inserted.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>While the item is being moved into (or created in) a container, by user dragging, script function, or the core.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'CanInsertScript' property defines the location of the can insert script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script allows control over what items may be inserted into a container by returning 1 or 0. This script is called fairly often, and is run critical, so try not to do too many calculations in it.</explain>
    <explain>IMPORTANT: the first parameter (character) MAY be passed as an uninitialized object if the item was not moved by character (i.e. by a script function or the core), so please check it before you use it.</explain>
    <explain>inserttype will be INSERT_ADD_ITEM if a new item is being inserted into the container (existing_stack and amt_to_add are uninit), or INSERT_INCREASE_STACK if an existing item's amount is merely being increased (note 'adding_item' can be uninit if one of the CreateItem functions is merely adding to an existing stack, as opposed to a client action)</explain>
    <explain>These are the times when canInsert scripts are called: Client drag/drop, vendor buy: when moving items to the player's backpack, vendor sell: when putting gold in the player's backpack, secure trade, when cancelling or confirming a trade, MoveItemToContainer, CreateItemInContainer, CreateItemInInventory, CreateItemInBackpack.</explain>
    <explain>You should not destroy the adding_item in the CanInsert script.</explain>
    <example>
use uo;
const MAX_WEIGHT := 400;
program my_example_caninsertscript(character, container, movetype, inserttype, 
                                   adding_item, existing_stack, amount_to_add)
    if(character != error)
      if(inserttype == INSERT_ADD_ITEM)
        if(character.weight + adding_item.weight > MAX_WEIGHT)
            return 0;
        else
            return 1;
        endif
      else
        if(adding_item)
          if(character.weight + adding_item.weight > MAX_WEIGHT)
            return 0;
          else
            return 1;
          endif
        else //need to go by the amount to add
          var weight_per_item := CDbl(existing_stack.weight) / CDbl(existing_stack.amount);         
          if(character.weight + (weight_per_item * amount_to_add) > MAX_WEIGHT)
            return 0;
          else
            return 1;
          endif
        endif
      endif          
    else
        return 1;
    endif
endprogram</example>
    <example>
UO.EM constants used with the 'movetype' parameter:    
const MOVETYPE_PLAYER     := 0; // physically moved (dragged) by a player
const MOVETYPE_COREMOVE   := 1; // moved by the core (eg, MoveItemToContainer().)
Insert scripts only:
const MOVETYPE_CORECREATE := 2; // created by core (eg, CreateItemInBackpack().)</example>
	<example>
UO.em constants used with the 'inserttype' parameter:
const INSERT_ADD_ITEM        := 1;
const INSERT_INCREASE_STACK  := 2;</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Container</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>OnInsertScript</relatedtype>
    <relatedtype>CanRemoveScript</relatedtype>
    <relatedtype>OnRemoveScript</relatedtype>
</scripttype>


<scripttype name="CanRemoveScript">
    <prototype>program canremovescript(character, container, item, movetype)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="container" value="Container Ref" />
    <parameter name="item" value="Item Ref" />
    <parameter name="movetype" value="Integer" />
    <return>If 1, item is allowed to be removed from the container, else it is not removed.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>While the item is being moved out of a container, by user dragging, script function, or the core.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'CanRemoveScript' property defines the location of the can remove script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script allows control over what items may be removed from a container by returning 1 or 0. This script is called fairly often, and is run critical, so try not to do too many calculations in it.</explain>
    <explain>IMPORTANT: the first parameter (character) MAY be passed as an uninitialized object if the item was not moved by character (i.e. by a script function or the core), so please check it before you use it.</explain>
    <explain>You should not destroy the item in the CanRemove script.</explain>
    <example>
use uo;
program my_example_canremovescript(character, container, item)
    var cursed := GetObjPropert(item,"cursed");
    if(cursed == 1)
        return 0;
    else
        return 1;
endprogram</example>
    <example>
UO.EM constants used with the 'movetype' parameter:    
const MOVETYPE_PLAYER     := 0; // physically moved (dragged) by a player
const MOVETYPE_COREMOVE   := 1; // moved by the core (eg, MoveItemToLocation().)</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Container</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>OnInsertScript</relatedtype>
    <relatedtype>CanInsertScript</relatedtype>
    <relatedtype>OnRemoveScript</relatedtype>
</scripttype>


<scripttype name="OnInsertScript">
    <prototype>program oninsertscript(character, container, movetype, inserttype, adding_item, existing_stack, amount_to_add)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="container" value="Container Ref" />
    <parameter name="movetype" value="Integer" />
    <parameter name="inserttype" value="Integer" />
    <parameter name="adding_item" value="Item Ref" />
    <parameter name="existing_stack" value="Item Ref" />
    <parameter name="amount_to_add" value="Integer" />
    <return>return value ignored</return>
    <schedtype>Run-To-Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>After the item is moved into (or created in) a container, by user dragging, script function, or the core.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'OnInsertScript' property defines the location of the on-insert script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script allows side effects to be triggered as a result of the item insertion.</explain>
    <explain>IMPORTANT: the first parameter (character) MAY be passed as an uninitialized object if the item was not moved by character (i.e. by a script function or the core), so please check it before you use it.</explain>
    <explain>inserttype will be INSERT_ADD_ITEM if a new item is being inserted into the container (existing_stack and amt_to_add are uninit), or INSERT_INCREASE_STACK if an existing item's amount is merely being increased (and adding_item is uninit).</explain>
    <explain>These are the times when onInsert scripts are called: Client drag/drop, vendor buy: when moving items to the player's backpack, vendor sell: when putting gold in the player's backpack, secure trade, when cancelling or confirming a trade, MoveItemToContainer, CreateItemInContainer, CreateItemInInventory, CreateItemInBackpack.</explain>    
    <example>
use uo;
program my_example_oninsertscript(character, container, movetype, inserttype, adding_item, 
                                  existing_stack, amount_to_add)
    if(inserttype == INSERT_INCREASE_STACK )
      SendSysmessage(character,"You insert " + amount_to_add + " more " 
                   + existing_stack.desc + " into the container.");
    else
      SendSysmessage(character,"You insert a " + adding_item.desc + " into the container.");
    endif
    PlaySoundEffectPrivate(character, SFX_INSERT, character);
endprogram</example>
    <example>
UO.EM constants used with the 'movetype' parameter:    
const MOVETYPE_PLAYER     := 0; // physically moved (dragged) by a player
const MOVETYPE_COREMOVE   := 1; // moved by the core (eg, MoveItemToContainer().)
Insert scripts only:
const MOVETYPE_CORECREATE := 2; // created by core (eg, CreateItemInBackpack().)</example>
	<example>
UO.em constants used with the 'inserttype' parameter:
const INSERT_ADD_ITEM        := 1;
const INSERT_INCREASE_STACK  := 2;</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Container</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>CanInsertScript</relatedtype>
    <relatedtype>CanRemoveScript</relatedtype>
    <relatedtype>OnRemoveScript</relatedtype>
</scripttype>


<scripttype name="OnRemoveScript">
    <prototype>program onremovescript(character, container, item, item_amount, movetype)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="container" value="Container Ref" />
    <parameter name="item" value="Item Ref" />
    <parameter name="item_amount" value="Integer" />
    <parameter name="movetype" value="Integer" />
    <return>return value ignored</return>
    <schedtype>Run-To-Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>After the item is out of a container, by user dragging, script function, or the core.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'OnRemoveScript' property defines the location of the on-remove script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control.</todefine>
    <explain>This script allows side effects to be triggered as a result of the item removal.</explain>
    <explain>IMPORTANT: the first parameter (character) MAY be passed as an uninitialized object if the item was not moved by character (i.e. by a script function or the core), so please check it before you use it.</explain>
    <example>
use uo;
program my_example_onremovescript(character, container, item, item_amount)
    SendSysmessage(character,"You removed " + item_amount + " " 
                   + item.desc + " from the container.");
    PlaySoundEffectPrivate(character, SFX_REMOVE, character);
endprogram</example>
    <example>
UO.EM constants used with the 'movetype' parameter:    
const MOVETYPE_PLAYER     := 0; // physically moved (dragged) by a player
const MOVETYPE_COREMOVE   := 1; // moved by the core (eg, MoveItemToLocation().)</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Container</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>CanInsertScript</relatedtype>
    <relatedtype>OnInsertScript</relatedtype>
    <relatedtype>CanRemoveScript</relatedtype>
</scripttype>

<scripttype name="EquipScript">
    <prototype>program equipscript(character, item, startup)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="item" value="Item Ref" />
    <parameter name="startup" value="Integer 0/1 if item is being equipped due to server start" />
    <return>1 if the item should be equipped, 0 to disallow equipping.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When the item is being equipped on character, either by client dragging or script function, after the equiptest.ecl check is passed.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'EquipScript' property defines the location of the equip script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control. Also, setting item.equipscript allows you to change the script.</todefine>
    <explain>This script allows side effects to be triggered as a result of the item being equipped on a character.</explain>
    <explain>Also can be used to disallow equipping, by the return value.</explain>
    <explain>Doesn't make sense for items that cannot be equipped, like walls or doors and such.</explain>
    <example>
use uo;
const FOR_CLASS := &quot;warrior&quot;;
program my_example_equipscript(character, item, startup)
    var class := GetObjProperty(character, &quot;class&quot;);
    if(class != FOR_CLASS)
        if(!startup)
            SendSysmessage(character,&quot;Your class may not equip that item.&quot;);
        endif
        return 0;
    else
        return 1;
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>UnEquipScript</relatedtype>
    <relatedtype>EquipTestScript</relatedtype>
    <relatedtype>UnEquipTestScript</relatedtype>
</scripttype>


<scripttype name="UnEquipScript">
    <prototype>program unequipscript(character, item)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="item" value="Item Ref" />
    <return>1 if the item should be unequipped, 0 to disallow unequipping.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When the item is being unequipped by character, either by client dragging or script function, after the unequiptest.ecl check is passed.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/control</wherelives>
    <todefine>In the item's itemdesc.cfg entry, the 'UnEquipScript' property defines the location of the unequip script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control. Also, setting item.unequipscript allows you to change the script.</todefine>
    <explain>This script allows side effects to be triggered as a result of the item being unequipped by a character.</explain>
    <explain>Also can be used to disallow unequipping, by the return value.</explain>
    <explain>Doesn't make sense for items that cannot be equipped, like walls or doors and such.</explain>
    <example>
use uo;
program my_example_equipscript(character, item, startup)
    var cursed := GetObjProperty(item, "cursed");
    if(cursed == 1)
        SendSysmessage(character,"That item is cursed! Gwuahahahaha!!");
        return 0;
    else
        return 1;
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>UnEquipScript</relatedtype>
    <relatedtype>EquipTestScript</relatedtype>
    <relatedtype>UnEquipTestScript</relatedtype>
</scripttype>


<scripttype name="UnEquipTestScript">
    <prototype>program unequiptest(character, item, startup)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="item" value="Item Ref" />
    <parameter name="startup" value="always false" />
    <return>1 if the item can be unequipped, 0 to disallow unequipping.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When the item is being unequipped by character, either by client dragging or script function.</whencalled>
    <wherelives>The 'program' in the unequiptest.src file, in a package or /scripts/misc (only one should exist in the system)</wherelives>
    <todefine></todefine>
    <explain>This script allows side effects to be triggered as a result of the item being unequipped by a character.</explain>
    <explain>This script is common for all items, and is called for each. useful for unequip checks that are the same for all items, so the code does not need to be replicated in all UnEquipScripts.</explain>
    <example>
use uo;
program my_example_unequiptest(character, item, startup)
    var cursed := GetObjProperty(item, "cursed");
    if(cursed == 1)
        SendSysmessage(character,"That item is cursed! Gwuahahahaha!!");
        return 0;
    else
        return 1;
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>EquipScript</relatedtype>
    <relatedtype>UnEquipScript</relatedtype>
    <relatedtype>EquipTestScript</relatedtype>
</scripttype>


<scripttype name="EquipTestScript">
    <prototype>program equiptest(character, item, startup)</prototype>
    <parameter name="character" value="Character Ref, or uninitialized, see below" />
    <parameter name="item" value="Item Ref" />
    <parameter name="startup" value="Integer 0/1 if item is being equiped on startup" />
    <return>1 if the item can be equipped, 0 to disallow equipping.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When the item is being equipped by character, either by client dragging or script function.</whencalled>
    <wherelives>The 'program' in the equiptest.src file, in a package or /scripts/misc (only one should exist in the system)</wherelives>
    <todefine></todefine>
    <explain>This script allows side effects to be triggered as a result of the item being equipped by a character.</explain>
    <explain>This script is common for all items, and is called for each. useful for equip checks that are the same for all items, so the code does not need to be replicated in all EquipScripts.</explain>
    <example>
use uo;
program my_example_equiptest(character, item, startup)
    var firstletter := lower(character.name[1]);
    if(firstletter == "t")
        SendSysmessage(character,"Sorry, character name starting with 
                       't' can't equip any items, for some reason.");
        return 0;
    else
        return 1;
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
    <relatedtype>EquipScript</relatedtype>
    <relatedtype>UnEquipScript</relatedtype>
    <relatedtype>UnEquipTestScript</relatedtype>
</scripttype>


<scripttype name="HitScript">
    <prototype>program hitscript(attacker, defender, weapon, armor, basedamage, rawdamage )</prototype>
    <parameter name="attacker" value="Character Ref of player attacking with weapon" />
    <parameter name="defender" value="Character Ref" />
    <parameter name="weapon" value="Weapon Ref" />
    <parameter name="armor" value="Armor Ref, or 0 if no armor was hit." />
    <parameter name="basedamage" value="Integer damage amount due to random weapon damage, strength, and tactics." />
    <parameter name="rawdamage" value="Integer damage amount due basedamage, minus amount absorbed by armor." />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a weapon with a hit script defined successfully hits an opponent. (note not called automatically if Attack syshook is called)</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/items</wherelives>
    <todefine>In the weapon's itemdesc.cfg entry, the 'HitScript' property defines the location of the hit script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/control. Also, setting weapon.hitscript allows you to change the script.</todefine>
    <explain>This script allows the scripter to control damage dealt to a defender, equipment, and to trigger extra effects like poisoned weapons.</explain>
    <explain>Only one core-called hitscript may be defined per weapon.</explain>
    <example>
use uo;
use util;
program my_example_hitscript(attacker, defender, weapon, armor, basedamage, rawdamage)
    ApplyDamage(defender,rawdamage);
    if(RandomInt(20) == 2)
        armor.hp := armor.hp - 1;
    endif
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Item</relatedobj>
    <relatedobj>Weapon</relatedobj>
    <relatedcfg>itemdesc.cfg</relatedcfg>
</scripttype>


<scripttype name="AIScript">
    <prototype>program AIscript()</prototype>
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When an NPC is created (either new or from world save on startup)</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/ai</wherelives>
    <todefine>In the NPC's npcdesc.cfg entry, the 'Script' property defines the location of the AI script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/ai. Also, setting npc.script allows you to change the script.</todefine>
    <explain>This script acts as an NPC's control script, allowing it to move, fight, and react to events. This script should not exit until the NPC dies, or the NPC will become 'braindead'. Normally there exists a loop where events are processed and other actions are performed.</explain>
    <explain>This is the only script type where NPC.EM functions are allowed.</explain>
    <example>
//Not a completely usable AI script, for example, doesn't close the distance to an opponent
// or react to other sysevents.
use uo;
use npc;
use os;
include "include/sysEvent";
var me;
program my_example_aicript()
    var me := Self();
    var event;
    EnableEvents(SYSEVENT_SPEECH,5);
    EnableEvents(SYSEVENT_ENGAGED);
    while(me)
        event := wait_for_event(15);
        if(event)
            case(event.type)
                SYSEVENT_SPEECH: Say( event.source.name + " said: " + event.text );
                SYSEVENT_ENGAGED: SetOpponent( event.source );
            endcase
        endif
        Wander();
    endwhile
endprogram</example>
    <relatedobj>NPC</relatedobj>
    <relatedcfg>npcdesc.cfg</relatedcfg>
</scripttype>


<scripttype name="AttackHitScript">
    <prototype>program attackhitscript(attacker, defender, weapon, armor, basedamage, rawdamage )</prototype>
    <parameter name="attacker" value="Character Ref of player attacking with weapon" />
    <parameter name="defender" value="Character Ref" />
    <parameter name="weapon" value="Weapon Ref" />
    <parameter name="armor" value="Armor Ref, or 0 if no armor was hit." />
    <parameter name="basedamage" value="Integer damage amount due to random weapon damage, strength, and tactics." />
    <parameter name="rawdamage" value="Integer damage amount due basedamage, minus amount absorbed by armor." />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a weapon with a hit script defined successfully hits an opponent. (note not called automatically if Attack syshook is called)</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/items</wherelives>
    <todefine>In the NPC's npcdesc.cfg entry, the 'AttackHitScript' property defines the location of the NPC's intrinsic weapon hit script. This is in package format ':pkgname:scriptname', or if just 'scriptname' in the same package, or /scripts/items.</todefine>
    <explain>This script acts the same as a HitScript, but it is for an NPC's "intrinsic weapon" which is a fake weapon for NPCs that attack with bare fists. See HitScript and npcdesc.cfg.</explain>
    <example>
program MainHitScript(attacker, defender, weapon, armor, basedamage, rawdamage)
	//
	// Cheat checker
	//
	if ( attacker == defender )
		ApplyRawDamage(attacker, 1000);
	elseif ( attacker.hidden || defender.hidden )
		return 0;
	elseif ( !attacker.npctemplate )
		if ( !attacker.warmode )
			basedamage := CInt(basedamage/2);
			rawdamage := CInt(rawdamage/2);
		endif
	endif
endprogram
    </example>
    <relatedobj>Weapon</relatedobj>
    <relatedobj>NPC</relatedobj>
    <relatedcfg>npcdesc.cfg</relatedcfg>
    <relatedtype>HitScript</relatedtype>
</scripttype>


<scripttype name="DeathScript">
    <prototype>program death(corpse)</prototype>
    <parameter name="corpse" value="NPC corpse ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When an NPC is killed.</whencalled>
    <wherelives>The 'program' in the death.src file, only in /scripts/misc (only one should exist in the system)</wherelives>
    <todefine>This script is called for all NPCs.</todefine>
    <explain>This script allows side effects to be triggered as a result of NPC death, like unmounting players off their dying mount, playing death sounds, etc.</explain>
    <explain>This script is common for all NPCs, and is called for each.</explain>
    <example>
use uo;
program my_example_death(corpse)
    PrintTextAbove(corpse,"ARRRRGH");
    PlaySoundEffect(SFX_VICTORY); //fake constant
endprogram</example>
    <relatedobj>Corpse</relatedobj>
    <relatedobj>NPC</relatedobj>
    <relatedcfg>npcdesc.cfg</relatedcfg>
    <relatedtype>ChrDeathScript</relatedtype>
</scripttype>


<scripttype name="ChrDeathScript">
    <prototype>program chrdeath(corpse, ghost)</prototype>
    <parameter name="corpse" value="Player corpse ref" />
    <parameter name="ghost" value="Character Ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When an Player Character is killed.</whencalled>
    <wherelives>The 'program' in the chrdeath.src file, only in /scripts/misc (only one should exist in the system)</wherelives>
    <todefine>This script is called for all Players.</todefine>
    <explain>This script allows side effects to be triggered as a result of Player death, like unmounting players off their mount, allowing ghosts to report their murderer, Auto-Resurrect choices, etc.</explain>
    <example>
use uo;
program my_example_chrdeath(corpse,ghost)
    Broadcast(ghost.name + "'s death cry is heard throughout the realm!");
    //useful stuff here...
endprogram</example>
    <relatedobj>Corpse</relatedobj>
    <relatedobj>Character</relatedobj>
    <relatedtype>death.ecl</relatedtype>
</scripttype>


<scripttype name="ConsoleScript">
    <prototype>program consolescript(cmd)</prototype>
    <parameter name="cmd" value="command string, i.e. 'B'" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When a character is entered into the POL Console, i.e. 'B'.</whencalled>
    <wherelives>The 'program' in a .src file, only in /scripts/console</wherelives>
    <todefine>Map a command character to a console script in /config/console.cfg</todefine>
    <explain>This script allows an administrator to activate POL scripts without needing to log into the game. The scripts could be used to shut down theserver after a time, or print a online character list, etc.</explain>
    <example>
There are four special command script names:
[lock]              lock the console
[unlock]            unlock the console
[lock/unlock]       toggle the lock status of the console
[threadstatus]      will display thread status and checkpoints</example>
    <example>
// Print number of toplevel items in the world.
use uo;
program consolescript( cmd )
    print( "System Message: Current # of Toplevel Items - " + polcore().itemcount );
endprogram</example>
    <relatedcfg>console.cfg</relatedcfg>
</scripttype>


<scripttype name="TextCommandScript">
    <prototype>program textcommand(character, text, uc_text, langcode)</prototype>
    <parameter name="character" value="Character ref activating this script" />
    <parameter name="text" value="String after command name" />
    <parameter name="langcode" value="3-character string, representing the client's language code, i.e. 'ENU', 'DEU', 'RUS', etc.(exist if client used unicode speech)" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player character 'speaks' a command string, i.e. '.online'</whencalled>
    <wherelives>The 'program' in a .src file, in a command level subdir of a package or /scripts/textcmd</wherelives>
    <todefine>Place the script in a command level subdir or /scripts/textcmd, or a package after defining the command level path in cmds.cfg.</todefine>
    <explain>This script allows a player to activate a script, according to their command level. I.e. 'admin' level can activate admin and below (gm, seer, etc), but a GM could not activate 'admin' commands.</explain>
    <explain>Lots of things can be done with this script type, including creating objects, destroying them, showing gump menus, teleporting, or anything that the core functions allow!</explain>
    <explain>'text' is all the text after the command name. I.e. '.createstack 0xEED 100' would make 'text' be '0xEED 100'. This is a great place to use SplitWords (note result is still a string, so use Cint() if expecting integers).</explain>
    <explain>Only one text command script may be active on a player at a time.</explain>
    <explain>Unicode array: array of integers representing unicode characters</explain> 
    <example>
// a teleport script. Should be entered with x y z numbers after the name.    
use uo;
program textcmd( character, text )
    var arr := SplitWords( text );
    MoveCharacterToLocation( character,Cint(arr[1]),Cint(arr[2]),Cint(arr[3]) );
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedcfg>cmds.cfg</relatedcfg>
</scripttype>

<scripttype name="DblClickSelfScript">
    <prototype>program dblclickself(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player character double clicks on himself or herself. Not called with the "open paperdoll" client macro.</whencalled>
    <wherelives>The 'program' in dblclickself.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called on doubleclick.</todefine>
    <explain>This script allows an alternate behavior other than the default 'open paperdoll' behavior. Useful for things like dismounting.</explain>
    <example>
use uo;
include "include/client";
program dblclickself( me )
	var mount := GetEquipmentByLayer( me, LAYER_MOUNT );
	if (!mount)
		OpenPaperdoll( me, me );
		return;
	endif
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>

<scripttype name="DblClickOtherScript">
    <prototype>program dblclickother(character, mobile_clicked)</prototype>
    <parameter name="character" value="Character ref" />
    <parameter name="mobile_clicked" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player double clicks another player or npc. Will not run if the npc has the double click event enabled.</whencalled>
    <wherelives>The 'program' in dblclickother.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called on doubleclick.</todefine>
    <explain>This script allows an alternate behavior other than the default 'open paperdoll' behavior.</explain>
    <example>
use uo;
use os;
use npc;

program core_dblClickSelf(who, clicked)
	if ( HasPDGraphic(clicked) )
		return OPenPaperDoll(who, clicked);
	endif
	
	return 0;
endprogram

function HasPDGraphic(clicked)
	case ( clicked.graphic )
		400:	return 1; break; // Male
		401:	return 1; break; // Female
		402:	return 1; break; // Male ghost
		403:	return 1; break; // Female ghost
		987:	return 1; break; // GM robe
	endcase
	
	return 0;
endfunction
    </example>
    <relatedobj>Character</relatedobj>
</scripttype>

<scripttype name="DblClickItemScript">
  <prototype>program dblclickitem(character, item_clicked)</prototype>
    <parameter name="character" value="Character ref" />
    <parameter name="item_clicked" value="Item ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player double clicks a item.</whencalled>
    <wherelives>The 'program' in dblclickitem.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called on doubleclick.</todefine>
    <relatedobj>Character</relatedobj>
</scripttype>

<scripttype name="SkillWinScript">
    <prototype>program skillwin(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player character requests the skills scroll gump to be displayed.</whencalled>
    <wherelives>The 'program' in skillwin.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows an alternate behavior other than the default skills window behavior. Useful for implimenting your own skills gump for your custom shard.</explain>
    <example>
use uo;
program skillwin( character )
	if(character.cmdlevel > 0)
	    SendSkillWindow( character, character );
	else
	    SendMySkillGump( character );
	endif
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="LogonScript">
    <prototype>program logon(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When a client logs into the game server.</whencalled>
    <wherelives>The 'program' in logon.src file, in /scripts/misc or any package</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows code to run when the player logs in. Can be used for welcome messages, etc.</explain>
    <explain>This script runs critical, so be careful how much code you run!</explain>
    <example>
use uo;
program logon( character )
	SendSysmessage(character, "Welcome to POL.");
	Broadcast( character.name + " has entered the world.");
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>ReconnectScript</relatedtype>
    <relatedtype>LogoffScript</relatedtype>
    <relatedtype>LogoffTestScript</relatedtype>
</scripttype>


<scripttype name="ReconnectScript">
    <prototype>program reconnect(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When a client re-logs into the game server before his/her character is removed from the world (5 minutes default).</whencalled>
    <wherelives>The 'program' in reconnect.src file, in /scripts/misc or any package</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows code to run when the player logs in after having recently logged off.</explain>
    <example>
use uo;
program reconnect( character )
	Broadcast( character.name + " has reconnected.");
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>LogonScript</relatedtype>
    <relatedtype>LogoffScript</relatedtype>
    <relatedtype>LogoffTestScript</relatedtype>
</scripttype>


<scripttype name="LogoffTestScript">
    <prototype>program logofftest(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>Integer value returned is number of seconds to have the character 'linger' in the world.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When a client logs out.</whencalled>
    <wherelives>The 'program' in logofftest.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows the scripter to control how long the character lingers in the world after logoff.</explain>
    <example>
use uo;
program logofftest( character )
	if(character.cmdlevel > 0)
	    return 0;
	else
	    return 300;
	endif
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>LogonScript</relatedtype>
    <relatedtype>LogoffScript</relatedtype>
    <relatedtype>ReconnectScript</relatedtype>
</scripttype>


<scripttype name="LogoffScript">
    <prototype>program logoff(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>After the linger time expires after a client logs off.</whencalled>
    <wherelives>The 'program' in logoff.src file, in /scripts/misc or any package</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows the scripter to run cleanup code after a character exits the world. Useful for stuff like cleaning up summoned NPCs, etc.</explain>
    <example>
use uo;
program logoff( character )
	Broadcast(character.name + " exited the world." );
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>LogonScript</relatedtype>
    <relatedtype>LogoffTestScript</relatedtype>
    <relatedtype>ReconnectScript</relatedtype>
</scripttype>


<scripttype name="OnCreateScript">
    <prototype>program oncreate(character, skillids, profession)</prototype>
    <parameter name="character" value="Character ref" />
    <parameter name="skillids" value="Array of the 3 integer skill IDs chosen." />
    <parameter name="profession" value="Integer" />
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When a new player character is created by a client.</whencalled>
    <wherelives>The 'program' in oncreate.src file, only in /scripts/misc</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows the scripter to run code when a new character is created. Useful for giving out starting equipment, etc. Note that it doesn't run if the character was created via a script (for example, using account.addcharacter()).</explain>
    <example>
use uo;
include "include/startEqp";
program oncreate( character, skillids, profession )
	CreateStartingEquipment(character, skillids);
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>OnDeleteScript</relatedtype>
</scripttype>


<scripttype name="OnDeleteScript">
    <prototype>program ondelete(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>When a player character is deleted.</whencalled>
    <wherelives>The 'program' in ondelete.src file, in /scripts/misc or any package</wherelives>
    <todefine>If the compiled file exists it is automatically called.</todefine>
    <explain>This script allows the scripter to run code when a character is deleted. (Note: differently from the oncreate script, the ondelete script is called also when a character is deleted in a script.)</explain>
    <example>
use uo;
program ondelete( character )
	Broadcast(character.name + " was deleted.");
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedtype>OnCreateScript</relatedtype>
</scripttype>


<scripttype name="SkillScript">
    <prototype>program skillscript(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a uses a "direct" skill like Hiding, Cartography, etc. (a blue 'crystal' appears next to the skill name on the default skill scroll gump) Also called with the client macros UseSkill, LastSkill, etc.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/skills</wherelives>
    <todefine>Define a "Script" property in the attributes.cfg entry for the appropriate skill number.</todefine>
    <explain>This script type handles the directly-usable skills in UO. It is not used for skills used via an item (like blacksmithy).</explain>
    <explain>The script is 'attached' to the character, and he/she cannot use another skill or use an item until this skill script exits or calls Detach().</explain>
    <explain>The attributes.cfg entry defines the time delay for starting subsequent skill scripts</explain>
    <example>
//example hide skill script   
use uo;
program hideskill( character )
	if(character.cmdlevel > 0)
	    character.hidden := 1;
	else
	    //obviously some skill checks go here, etc.
	endif
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedcfg>attributes.cfg</relatedcfg>
</scripttype>


<scripttype name="SpellScript">
    <prototype>program spellscript(character, spell_id)</prototype>
    <parameter name="character" value="Caster Character ref" />
    <parameter name="spell_id" value="Integer" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player casts a spell from the normal UO spellbook.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts/spells</wherelives>
    <todefine>Define a "Script" property in the spells.cfg entry for the appropriate spell number.</todefine>
    <explain>This script type handles the 'cast spell #' action in UO, via a spellbook or client macro. spell_id is taken from 'SPELLID' entry in '::spells.cfg'.</explain>
    <example>
//example Lightning spell (#30), too simple to use directly!
use uo;
program lightning( character, spell_id )
	var tgt := Target(character, TGTOPT_HARMFUL);
	if(tgt)
	    if(tgt.isa(POLCLASS_MOBILE))
	        PlayLightningBoltEffect(tgt);
	        //some damage
	    endif
	endif
endprogram</example>
    <relatedobj>Character</relatedobj>
    <relatedcfg>spells.cfg</relatedcfg>
</scripttype>


<scripttype name="HelpScript">
    <prototype>program help(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player presses the "Help" button on the paperdoll.</whencalled>
    <wherelives>The 'program' in help.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>This script type handles help button on the paperdoll. Useful for implimenting a help gump or staff paging system.</explain>
    <example>
use uo;
program help( character )
    SendSysmessage(character,"You're helpless.");
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="BoatScript">
    <prototype>program boatcontrol(boat)</prototype>
    <parameter name="boat" value="Boat Ref" />
    <return>Return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>Immediately after the item is created (includes boot-up).</whencalled>
    <wherelives>The 'program' in the boat.src file, only in /scripts/misc</wherelives>
    <todefine>Always called when a boat is created/started.</todefine>
    <explain>This script acts as a control script for a boat. Use it for navigation commands (e.g. the tillerman control script), boat decay, etc.</explain>
    <example>
use uo;
use os;
program my_example_boatscript(boat)
    RegisterForSpeechEvents(boat.tillerman, 5);
    var who;
    while(boat) //exit loop if boat is destroyed
        ev := wait_for_event(120);
        if(ev)
            who := ev.source;
            PrintTextAbove(boat.tillerman, who.name + " is a scurvy dog for saying: " + ev.text);
        endif
    endwhile
endprogram</example>
    <relatedobj>Boat</relatedobj>
    <relatedtype>ControlScript</relatedtype>
</scripttype>


<scripttype name="StartScript">
    <prototype>no prototype, exists as inline code at global scope</prototype>
    <return>return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>Once, during server start.</whencalled>
    <wherelives>As inline code outside any function scope in start.src file, in any package and in /scripts</wherelives>
    <todefine>If the compiled file exists in /scripts or an enabled package it is automatically called.</todefine>
    <explain>This script allows the scripter to run code when the server starts, for housekeeping or starting background scripts like NPC spawners.</explain>
    <example>
use uo;
print("my package starting..");
//etc, your startup code! I'm so bad at examples.</example>
</scripttype>


<scripttype name="ExportedVitalsFunction">
    <prototype>exported function vitalsfunc(character)</prototype>
    <parameter name="character" value="Character Ref" />
    <parameter name="reason" value="Integer, see below only for DepletedFunction" />
    <return>Integer return used by core, see below, except for DepletedFunction</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>Both exported functions on character create and when a script calls RecalcVitals(), or when vital reaches zero for DepletedFunction</whencalled>
    <wherelives>As exported functions in a .src, as defined in vitals.cfg.</wherelives>
    <todefine>Define vitals functions in vitals.cfg.</todefine>
    <explain>There exists 2 exported functions for vitals calculation: RegenRateFunction and MaximumFunction.</explain>
    <explain>Each vital defined should have both of these functions. RegenRateFunction should return the regeneration rate for that vital for that character (see vitals.cfg for format)</explain>
    <explain>MaximumFunction should return the maximum vital value for the character in hundreths of a point</explain>
    <explain>DepletedFunction gets called when the vital reaches 0 the reason parameter can have the following values</explain>
    <explain>0: Regenerate, 1: Damage, 2: Movement, 3: Death, 4: Resurrect, 5: Script</explain>
    <example>
//In a .src file, like regen.src:
//vitals.cfg defines MaximumFunction regen:GetLifeMaximumValueExported , etc.
//Life vital funcs:
use uo;
exported function GetLifeMaximumValueExported(mob) 
	return (GetAttribute(mob, ATTRIBUTEID_STRENGTH) * 100);
endfunction</example>
    <relatedobj>Character</relatedobj>
    <relatedcfg>vitals.cfg</relatedcfg>
</scripttype>


<scripttype name="SyshookScript">
    <prototype>exported function syshookname(params vary, see below)</prototype>
    <return>return value usage varies, see below</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>At various times, depending on the syshook, see below.</whencalled>
    <wherelives>As exported functions in a .src, as defined in syshook.cfg or uopacket.cfg.</wherelives>
    <todefine>Define a system hook script in a syshook.cfg or a packet hook script in a uopacket.cfg.</todefine>
    <explain>The valid system hook names are:</explain>
    <explain><code>CheckSkill, OpenSpellbook, GetBookPage, CombatAdvancement, ParryAdvancement, Attack, Pushthrough, SpeechMul, HitMiss, OnCast, CanDecay, Ouch, CanDie, UnHide, CloseCustomHouse, WarmodeChange, CanTrade, ConsumeAmmunition</code></explain>
    <explain>You can use any name in packet hook script (ReceiveFunction/SendFunction - you can find examples in packethooks.txt).</explain>
	  <explain>Note: You must define a "program" named scriptname in the file scriptname. This program should perform any substantive initialization for supporting the individual hooks in the file. Return 1 to install the hooks, or 0 to disable. This will be run only once on startup.</explain>
    <explain><code>CheckSkill:</code></explain>
    <explain>params: CharRef character, Int skillid, Int difficulty, Int pointvalue. When called: UO.EM::CheckSkill() is called. Return: true/false for skill use success.</explain>
    <explain><code>OpenSpellbook:</code></explain>
    <explain>params: CharRef character. When called: A Character uses a spellbook object. Used to override normal spellbook behavior.</explain>
    <explain><code>GetBookPage:</code></explain>
    <explain>not implimented</explain>
    <explain><code>CombatAdvancement:</code></explain>
    <explain>params: CharRef character, WeaponRef weapon, CharRef opponent. When called: Whenever a character attacks another, before hit is determined. Used to override normal combat skill advancement.</explain>
    <explain><code>ParryAdvancement:</code></explain>
    <explain>params: CharRef character, WeaponRef weapon, CharRef opponent, ItemRef opponent_shield. When called: A Character attacks another whom wields a shield, before parry success is determined. Used to override 'parry' skill advancement.</explain>
    <explain><code>Attack:</code></explain>
    <explain>params: CharRef character, CharRef opponent. When called: A Character attacks another. IMPORTANT: completely overrides core handling of combat, including the above advancement hooks and ammunition hooks. You must handle all of combat yourself in a script if you use this hook (determining hits, applying damage, destroying ammo, skill advancement, etc). Since it is called for every attack, this is a very CPU expensive hook to implement.</explain>
    <explain><code>Pushthrough:</code></explain>
    <explain>params: CharRef character, Array of CharRefs in destination tile. When called: on EVERY move of EVERY character. Return: true if walk ok, false to block walk. Used to override the default core behavior of blocking the movement if a tile is already occupied by another mobile. NOTE: The client also performs pushthrough checks (for some realms) and must be patched if you only want server-side checks. Since this critical script is called so often, it should be kept short.</explain>
    <explain><code>SpeechMul:</code></explain>
    <explain>params: CharRef character, Array of speechtokens, String complete msg. When called: When someone says a speech.mul keyword (one or more).</explain>
    <explain><code>HitMiss:</code></explain>
    <explain>params: CharRef character, CharRef opponent. When called: Hitchance check fails</explain>
    <explain><code>OnCast:</code></explain>
    <explain>params: CharRef character, Int SpellID. When called: When char casts a spell (including macros) before all checks. Return: 0 if you wish POL to perform the checks and casting, 1 if you want to handle it fully scriptside.</explain>
    <explain><code>CanDecay:</code></explain>
    <explain>params: ItemRef item. When called: When item should decay. Return: 0  core decay will ignore item and continue on the cycler, 1 core decay will handle the item as normal.</explain>
    <explain><code>Ouch:</code></explain>
    <explain>params: CharRef mobile, Int lastx, Int lasty, Int, lastz. When called: When mobiles falls at least 22 tiles.</explain>
    <explain><code>CanDie:</code></explain>
    <explain>params: CharRef mobile. When called: When mobiles is about to die. Return: 0 core stops death, 1 core will continue.</explain>
    <explain><code>UnHide:</code></explain>
    <explain>params: CharRef mobile. When called: When mobiles is about to unhide. Return: 0 stops the char from unhiding, 1 core will continue.</explain>
	  <explain><code>ReceiveFunction:</code></explain>
	  <explain>params: CharRef character, Packet byref packet. When called: When the server receives a packet by client. Return: 0 if you wish POL to perform its normal data processing on the packet (if any default packet handler exists for this packet ID), or 1 if you wish POL to do no processing on the packet (i.e. your script handled it fully).</explain>
	  <explain><code>SendFunction:</code></explain>
	  <explain>params: CharRef character, Packet byref packet. When called: When the server will send a packet to the client. Return: 0 if you wish POL to perform its normal data processing on the packet (if any default packet handler exists for this packet ID), or 1 if you wish POL to do no processing on the packet (i.e. your script handled it fully). You MUST NOT use the SendPacket or SendAreaPacket methods on the passed-in packet with SendFunction. Rather, edit the packet as you wish, and return 0. POL will send the packet as normal. You may create and send a different packet (NOT the same Packet ID, else the send functions will loop) from within this function, but note the sending order will be created packet, then hooked packet (if you return 0).</explain>
    <explain><code>CloseCustomHouse:</code></explain>
    <explain>params: CharRef mobile, MultiRef multi. When called: When mobiles quits house editing. Return: Ignored.</explain>
    <explain><code>WarmodeChange:</code></explain>
    <explain>params: CharRef mobile, Integer new_status. When called: When mobile changes the warmode. Return: Ignored.</explain>
    <explain><code>CanTrade:</code></explain>
    <explain>params: CharRef mobile, CharRef drop_on, ItemRef item. When called: When dropping an item on a character or when trying to add an item to a tradewindow. Return: 0 disallow trade, 1 core will continue.</explain>
    <explain><code>ConsumeAmmunition:</code></explain>
    <explain>params: CharRef attacker, ItemRef weapon. When called: the combat system goes to perform the ammunition consumption check. Note: This is overruled by an active Combat Hook Return: 0 disallow fire, 1 fire weapon, -1 use core consumption.</explain>
    <example>
//Pushthrough hook example    
//syshook.cfg defines: 
SystemHookScript pushhook.ecl
{
	Pushthrough Pushthrough
}
//in pushhook.src:
use uo;
program PushthroughHook()
	return 1;
endprogram

exported function Pushthrough(walker, obstructors)
	//print(walker.name);
	//foreach mob in obstructors   //note, obstructors is an array of char refs
	//	print(mob.name);
	//endforeach
	
	if(GetVital(walker,"Stamina") &lt; GetVitalMaximumValue(walker,"Stamina"))
		return 0;
	else
		return ConsumeVital(walker,"Stamina",1000);
	endif
endfunction</example>
    <relatedcfg>syshook.cfg</relatedcfg>
    <relatedcfg>uopacket.cfg</relatedcfg>
</scripttype>


<scripttype name="AuxServiceScript">
    <prototype>program auxservice(connection)</prototype>
    <parameter name="connection" value="Aux Connection Object" />
    <return>return value ignored, exiting aux service script closes connection.</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When a network connection is created on the defined port in auxsvc.cfg.</whencalled>
    <wherelives>The 'program' in a .src file, in a package.</wherelives>
    <todefine>Define the 'Script' property in auxsvc.cfg.</todefine>
    <explain>This script allows a scripter to communicate with an external TCP/IP application, using the normal POL packed string format for communcation.</explain>
    <explain>wait_for_event allows packet reads, with ev.type == "recv" and ev.value the unpacked data.</explain>
    <explain>connection.transmit(unpacked object) is the interface for sending data to the external application.</explain>
    <explain>If you save the service script PID to a global variable, other scripts may communicate with the external application via your service script.</explain>
    <example>
//auxsvc.cfg:
AuxService
{
    Port 5009
    Script aux1
}
//aux1.src:
use uo;
use os;
program auxtest( connection )
	var ev;
	print( "aux service is running" );
	while (connection)
		ev := wait_for_event( 5 );
		if (ev)
			print(ev.value);
		endif
	endwhile
	print( "aux connection closed" );
endprogram</example>
    <relatedobj>AuxConnection</relatedobj>
    <relatedcfg>auxsvc.cfg</relatedcfg>
</scripttype>


<scripttype name="CanDeleteScript">
    <prototype>program candelete( character, deleteby )</prototype>
    <parameter name="character" value="Character Ref" />
    <parameter name="deleteby" value="Integer" />
	<return>If 1, character is allowed to be removed from account, else it is not removed.</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>critical</def_prio>
    <whencalled>Before character deletion.</whencalled>
    <wherelives>The 'program' in a .src file, in /scripts/misc</wherelives>
    <todefine>This script is called for all Players.</todefine>
    <explain>This script allows control over what character may be removed by returning 1 or 0. This script is run critical, so try not to do too many calculations in it.</explain>
    <example>
UO.EM constants used with the 'deleteby' parameter:    
const DELETE_BY_PLAYER := 0; // Delete-Request by Player
const DELETE_BY_SCRIPT := 1; // Delete-Request by account.DeleteCharacter( index )
</example>
    <relatedobj>Character</relatedobj>
    <relatedobj>Account</relatedobj>
    <relatedtype>OnDeleteScript</relatedtype>
</scripttype>


<scripttype name="EnterScript">
    <prototype>program enterscript(mobile, region_name)</prototype>
    <parameter name="mobile" value="Character Ref" />
    <parameter name="region_name" value="String" />
    <return>Return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>Critical</def_prio>
    <whencalled>When a player enters the region.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts</wherelives>
    <todefine>In the regions's region.cfg or justice.cfg entry, the 'EnterScript' property defines the location of the script.</todefine>
    <explain>This script is called when the player enters the region.</explain>
    <example>
use uo;
program EnterRegionZone(mobile, region_name)
    ApplyRawDamage(mobile, 10000);
    SendSysMessage(mobile, "You just died because you entered an area that makes you dead!");
    return 1;
endprogram</example>
    <relatedcfg>regions.cfg</relatedcfg>
    <relatedcfg>justice.cfg</relatedcfg>
    <relatedtype>LeaveScript</relatedtype>
</scripttype>


<scripttype name="LeaveScript">
    <prototype>program leavescript(mobile, region_name)</prototype>
    <parameter name="mobile" value="Character Ref" />
    <parameter name="region_name" value="String" />
    <return>Return value ignored</return>
    <schedtype>Run To Completion</schedtype>
    <def_prio>Critical</def_prio>
    <whencalled>When a player leaves the region.</whencalled>
    <wherelives>The 'program' in a .src file, in a package or /scripts</wherelives>
    <todefine>In the regions's region.cfg or justice.cfg entry, the 'LeaveScript' property defines the location of the script.</todefine>
    <explain>This script is called when the player leaves the region.</explain>
    <example>
see EnterScript</example>
    <relatedcfg>regions.cfg</relatedcfg>
    <relatedcfg>justice.cfg</relatedcfg>
    <relatedtype>EnterScript</relatedtype>
</scripttype>


<scripttype name="GuildButtonScript">
    <prototype>program GuildButton(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player presses the "Guild" button on the paperdoll.</whencalled>
    <wherelives>The 'program' in guildbutton.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>This script type handles guild button on the paperdoll. Useful for implimenting a guild gump.</explain>
    <example>
use uo;
program GuildButton( character )
    SendSysmessage(character,"You clicked the Guildbutton.");
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="QuestButtonScript">
    <prototype>program QuestButton(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player presses the "Quest" button on the paperdoll.</whencalled>
    <wherelives>The 'program' in questbutton.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>This script type handles quest button on the paperdoll. Useful for implimenting a quest gump.</explain>
    <example>
use uo;
program QuestButton( character )
    SendSysmessage(character,"You clicked the Questbutton.");
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="VirtueButtonScript">
    <prototype>program VirtueButton(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player doubleclicks the "Virtue" (pentagram) button on the paperdoll.</whencalled>
    <wherelives>The 'program' in virtuebutton.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>This script type handles pentagram button on the paperdoll. Useful for implimenting any kind of gump.</explain>
    <example>
use uo;
program VirtueButton( character )
    SendSysmessage(character,"You doubleclicked the Pentagram.");
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="ChatButtonScript">
    <prototype>program ChatButton(character)</prototype>
    <parameter name="character" value="Character ref" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>When a player presses the "Chat" button.</whencalled>
    <wherelives>The 'program' in questbutton.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>This script type handles chat button. No chatsystem only catches the pressing.</explain>
    <example>
use uo;
program ChatButton( character )
    SendSysmessage(character,"You clicked the Chatbutton.");
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>


<scripttype name="CharProfileScript">
    <prototype>program CharProfile(character, of_who, mode, uctext)</prototype>
    <parameter name="character" value="Character ref" />
    <parameter name="of_who" value="Character ref" />
    <parameter name="mode" value="Integer" />
    <parameter name="uctext" value="Unicode character array" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>100</def_prio>
    <whencalled>On Profile opening and update request</whencalled>
    <wherelives>The 'program' in charprofile.src file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>if mode==0 (request) uctext is 0<br/>
        if mode==1 (update) uctext is new unicode array</explain>
    <example>
use uo;
program CharProfile(character, of_who, mode, uctext)
    if (mode == 0)
      print("Request");
      SendCharProfile(character, of_who, "Core test Title", CAscZ("Core test"), of_who.getprop("Profile"));
    else
      print("Update");
      of_who.setprop("Profile",uctext);
    endif
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>

<scripttype name="PopUpMenuScript">
    <prototype>program PopUpMenu(who, what)</prototype>
    <parameter name="who" value="Character ref, who requested the pop-up menu" />
    <parameter name="what" value="Object, reference to the item or mobile clicked" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>When a player single clicks an item, another player or an npc and UOFeatureEnable 0x08 is set.</whencalled>
    <wherelives>The 'program' in popupmenu.ecl file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>Use this script to send the pop-up menu with SendPopUpMenu().</explain>
    <example>use uo;
program popupmenu(who, what)
    print(who.name + " requested popup of " + CStr(what));

    var menu := array{};
    menu[10] := 3000484;
    menu[20] := struct{ cliloc := 3000487 };
    menu[30] := struct{ cliloc := 3000488, disabled := 1 };
    menu[40] := struct{ cliloc := 3000501, color := 0x1f };

    var ret := SendPopUpMenu( who, what, menu );
    print("Menu response:" + CStr(ret));
endprogram</example>
    <relatedobj>Character</relatedobj>
</scripttype>

<scripttype name="CustomHouseCommitScript">
    <prototype>program custom_house_commit( who, house )</prototype>
    <parameter name="who" value="Character ref, who is committing the house design" />
    <parameter name="house" value="House ref, the house being committed" />
    <return>return value ignored</return>
    <schedtype>Normal</schedtype>
    <def_prio>1</def_prio>
    <whencalled>After client presses the commit button.</whencalled>
    <wherelives>The 'program' in customhousecommit.ecl file, only in /scripts/misc</wherelives>
    <todefine>Automatically called if file exists.</todefine>
    <explain>To accept the changes call new method house.acceptcommit(chr,1) or
        house.acceptcommit(chr,0) to drop them. Unless you drop changes explicitly,
        the changes will be implicitly accepted.</explain>
    <explain>Main purpose should be calculation of cost (with delta support for later changes),
        link establishing of houseteleporters (0x181D - 0x1828)
        and adding a signhanger/sign if you didnt added it during multifoundation buildup.</explain>
    <explain>Doors and Teleporters are added to house components as normal items
        before this script is called, without any special treatment so dont forget to add
        scripts/itemdesc entries</explain>
    <explain>The core does not perform any validity checks on the elements, it's up to the script
        ensure that all house elements and components are valid graphics/objtypes.</explain>
    <explain>To get the current list of house parts use house.house_parts</explain>
    <explain>Important: while this script runs the client buildtool is still open and the client can still modify the house. So if a eg a confirm dialog is shown calculate the price also after the gump!</explain>
    <relatedobj>Character</relatedobj>
    <relatedobj>House</relatedobj>
    <relatedobj>Array</relatedobj>
    <relatedobj>Struct</relatedobj>
</scripttype>

</ESCRIPT>

