message("hello!")

# MESSAGE(FATAL_ERROR "${modules} Could not find FOO_EXEC.")


set(MODMAP_attributes AttributeExecutorModule)
set(MODMAP_basic BasicExecutorModule)
set(MODMAP_basicio BasicIoExecutorModule)
set(MODMAP_boat UBoatExecutorModule)
set(MODMAP_cfgfile ConfigFileExecutorModule)
set(MODMAP_cliloc ClilocExecutorModule)
set(MODMAP_datafile DataFileExecutorModule)
set(MODMAP_file FileAccessExecutorModule)
set(MODMAP_guilds GuildExecutorModule)
set(MODMAP_httpHttpExecutorModule)
set(MODMAP_math MathExecutorModule)
set(MODMAP_npc NPCExecutorModule)
set(MODMAP_os OSExecutorModule)
set(MODMAP_party PartyExecutorModule)
set(MODMAP_polsys PolSystemExecutorModule)
set(MODMAP_sql SQLExecutorModule)
set(MODMAP_storage StorageExecutorModule)
set(MODMAP_unicode UnicodeExecutorModule)
set(MODMAP_uo UOExecutorModule)
set(MODMAP_util UtilExecutorModule)
set(MODMAP_vitals VitalsExecutorModule)

function (read_decl em_name content)
  set(funcdefs "")
  set(funcIdx 0)
  while(1)
    string(LENGTH "${content}" out)
    if (${out} EQUAL 0)
      break()
    endif()
    string(STRIP "${content}" content)
    string(FIND "${content}" "//" out)
    if(${out} EQUAL 0)
      string(FIND "${content}" "\n" out)
      if(${out} GREATER_EQUAL 0)
        string(SUBSTRING "${content}" ${out} -1 content)
        continue()
      endif()
    endif()
    string(FIND "${content}" "const" out)
    if(${out} EQUAL 0)
      string(FIND "${content}" "\n" out)
      if(${out} GREATER_EQUAL 0)

        string(REGEX MATCH "^const[ ]+([_a-zA-Z]+)[:= \t]+([^;]*);" outconst "${content}")
        if (CMAKE_MATCH_1 AND CMAKE_MATCH_2)
          message("found const ${CMAKE_MATCH_1} : ${CMAKE_MATCH_2}")
          string(FIND ${CMAKE_MATCH_2} "\"" isstring)
          string(FIND ${CMAKE_MATCH_2} "array" isarray)
          string(FIND ${CMAKE_MATCH_2} "_DEFAULT_REALM" isrealm)

          if (${isstring} GREATER_EQUAL 0 OR ${isrealm} GREATER_EQUAL 0)
         #   file(APPEND ${TMP_FILE} "  std::string")
            if (${isrealm} GREATER_EQUAL 0)
              set(CMAKE_MATCH_2 "EM_${CMAKE_MATCH_2}")
            endif()
          elseif (${isarray} GREATER_EQUAL 0)
         #   file(APPEND ${TMP_FILE} "  std::array<int, 1>")
            set(CMAKE_MATCH_2 "{}")
          else()
         #   file(APPEND ${TMP_FILE} "  int")
          endif()
          #file(APPEND ${TMP_FILE} " EM_${CMAKE_MATCH_1} = ${CMAKE_MATCH_2};\n")
          set(constdef_written 1)
        endif()
        string(SUBSTRING "${content}" ${out} -1 content)
      endif()
      continue()
    endif()

    string(REGEX MATCH "^([a-zA-Z_]+)[\\( ]+([^;]*)[ \\)]+;" out "${content}")
    string(LENGTH "${out}" out)
    if (${out} EQUAL 0)
      break()
    endif()

    set(funcname "${CMAKE_MATCH_1}")
    message("found :")
    message(${funcname})
    string(APPEND funcdefs  "    { \"${funcname}\", { ${funcIdx} , ")
    MATH(EXPR funcIdx "${funcIdx}+1")

    if (CMAKE_MATCH_2)
      set(paramstr "${CMAKE_MATCH_2}")
      message(${paramstr})
      string(REGEX MATCHALL "," params "${paramstr}")
      list(LENGTH params n)
      math(EXPR n ${n}+1)
      message("params: ${n}")
      string(APPEND funcdefs "${n} } }, // ${paramstr}\n")
    else()
      message("params: 0")
      string(APPEND funcdefs "0 } },\n")
    endif()

    string(SUBSTRING "${content}" ${out} -1 content)
  endwhile()
  if (constdef_written)
    file(APPEND ${TMP_FILE} "\n")
  endif()
  file(APPEND ${TMP_FILE} " { \"${em_name}\", { \n")
  file(APPEND ${TMP_FILE} "${funcdefs}")
  file(APPEND ${TMP_FILE} " } },\n")
endfunction()

function (read_def modclass content)
  set(funcdefs "")
  while(1)
    string(LENGTH "${content}" out)
    if (${out} EQUAL 0)
      break()
    endif()
    string(STRIP "${content}" content)
    string(FIND "${content}" "//" out)
    if(${out} EQUAL 0)
      string(FIND "${content}" "\n" out)
      if(${out} GREATER_EQUAL 0)
        string(SUBSTRING "${content}" ${out} -1 content)
        continue()
      endif()
    endif()
    string(FIND "${content}" "const" out)
    if(${out} EQUAL 0)
      string(FIND "${content}" "\n" out)
      if(${out} GREATER_EQUAL 0)

        string(REGEX MATCH "^const[ ]+([_a-zA-Z]+)[:= \t]+([^;]*);" outconst "${content}")
        if (CMAKE_MATCH_1 AND CMAKE_MATCH_2)
          message("found const ${CMAKE_MATCH_1} : ${CMAKE_MATCH_2}")
          string(FIND ${CMAKE_MATCH_2} "\"" isstring)
          string(FIND ${CMAKE_MATCH_2} "array" isarray)
          string(FIND ${CMAKE_MATCH_2} "_DEFAULT_REALM" isrealm)

          if (${isstring} GREATER_EQUAL 0 OR ${isrealm} GREATER_EQUAL 0)
         #   file(APPEND ${TMP_FILE} "  std::string")
            if (${isrealm} GREATER_EQUAL 0)
              set(CMAKE_MATCH_2 "EM_${CMAKE_MATCH_2}")
            endif()
          elseif (${isarray} GREATER_EQUAL 0)
         #   file(APPEND ${TMP_FILE} "  std::array<int, 1>")
            set(CMAKE_MATCH_2 "{}")
          else()
         #   file(APPEND ${TMP_FILE} "  int")
          endif()
          #file(APPEND ${TMP_FILE} " EM_${CMAKE_MATCH_1} = ${CMAKE_MATCH_2};\n")
          set(constdef_written 1)
        endif()
        string(SUBSTRING "${content}" ${out} -1 content)
      endif()
      continue()
    endif()

    string(REGEX MATCH "^([a-zA-Z_]+)[\\( ]+([^;]*)[ \\)]+;" out "${content}")
    string(LENGTH "${out}" out)
    if (${out} EQUAL 0)
      break()
    endif()

    set(funcname "${CMAKE_MATCH_1}")
    message("found :")
    message(${funcname})
    string(APPEND funcdefs  "    { \"${funcname}\", &${modclass}::mf_${funcname}, ")
    if (CMAKE_MATCH_2)
      set(paramstr "${CMAKE_MATCH_2}")
      message(${paramstr})
      string(REGEX MATCHALL "," params "${paramstr}")
      list(LENGTH params n)
      math(EXPR n ${n}+1)
      message("params: ${n}")
      string(APPEND funcdefs "${n} }, // ${paramstr}\n")
    else()
      message("params: 0")
      string(APPEND funcdefs "0 },\n")
    endif()

    string(SUBSTRING "${content}" ${out} -1 content)
  endwhile()
  if (constdef_written)
    file(APPEND ${TMP_FILE} "\n")
  endif()
  file(APPEND ${TMP_FILE} "${funcdefs}")
  file(APPEND ${TMP_FILE} "};\n")
endfunction()

function(createfunctable em_name)
  # file(GLOB ems  "${EM_FOLDER}/*.em")
  set(TMP_FILE "${OUT_FOLDER}/${em_name}-tbl.h.tmp")
  set(OUT_FILE "${OUT_FOLDER}/${em_name}-tbl.h")
  file(WRITE ${TMP_FILE} "#ifndef _${em_name}FUNCTBL\n#define _${em_name}FUNCTBL\n")
  file(APPEND ${TMP_FILE} "namespace Pol\n{\nnamespace Bscript\n{\nusing namespace Module;\n\n")

  set(em "${EM_FOLDER}/${em_name}.em")
  set(modclass "${MODMAP_${em_name}}")
  message("${em} => ${em_name} => ${modclass}")
  file(APPEND ${TMP_FILE} "template <>\nconst char* TmplExecutorModule<${modclass}>::modname = \"${em_name}\";\n\ntemplate <>\nTmplExecutorModule<${modclass}>::FunctionTable\n  TmplExecutorModule<${modclass}>::function_table = {")
  FILE(READ ${em} contents)
  STRING(REGEX REPLACE ";" "\\\\;" contents "${contents}")
  #  message(${contents})

  read_def("${modclass}" ${contents})
  
  file(APPEND ${TMP_FILE} "\n\n")

  
  file(APPEND ${TMP_FILE} "} // namespace Bscript\n} // namespace Pol\n#endif\n")

  execute_process(
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    ${TMP_FILE}
    ${OUT_FILE}
  )
endfunction()


function(createmodlist)
  # file(GLOB ems  "${EM_FOLDER}/*.em")
  file(GLOB ems  "${EM_FOLDER}/*.em")
  set(TMP_FILE "${OUT_FOLDER}/modules.cpp.tmp")
  set(OUT_FILE "${OUT_FOLDER}/modules.cpp")
  file(WRITE ${TMP_FILE} "#include \"modmethods.h\"\n\n")
  file(APPEND ${TMP_FILE} "namespace Pol\n{
    namespace Bscript
    {

      CoreModuleContainer module_methods = {\n\n")

  foreach(em ${ems})
    get_filename_component(em_name ${em} NAME_WE)
    set(em "${EM_FOLDER}/${em_name}.em")
    message("${em} => ${em_name} => ${modclass}")
    FILE(READ ${em} contents)
    STRING(REGEX REPLACE ";" "\\\\;" contents "${contents}")
    #  message(${contents})

    read_decl(${em_name} ${contents})
    
  endforeach()
  file(APPEND ${TMP_FILE} "};\n\n")
  
  file(APPEND ${TMP_FILE} "} // namespace Bscript\n} // namespace Pol\n")

  execute_process(
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    ${TMP_FILE}
    ${OUT_FILE}
  )
endfunction()


set(modules attributes basic basicio boat cfgfile cliloc datafile file guilds http math npc os party polsys sql storage unicode uo util vitals)

foreach(iter ${modules})
  createfunctable(${iter})
endforeach()

createmodlist()