include "communication";
include "testutil";

use os;
use uo;
use boat;
use file;
use polsys;

var char;
var charX := 100;
var charY := 50;
var clientcon := getClientConnection();

enum Layers
  LAYER_SHIRT := 0x5 // Shirt
endenum

program test_item_move()
  var a := FindAccount( "testclient0" );
  char := a.getcharacter( 1 );
  if ( !char )
    return ret_error( "Could not find char at slot 1" );
  endif

  // Move character somewhere nice.
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return ret_error( $"Could not move character: ${res}" );
  endif

  return 1;
endprogram

/**
 * Tests
 * TODO: there is no lift "success" pkt
 *       currently it waits for 1s if a reject pkt is send
 *       this sync is needed because the chr itself gets moved out of range
 *       if the drop target is moved out of range this 1s delay shouldnt be needed
 */

// 1. Move item from ground into backpack
exported function lift_ground_drop_backpack()
  var item := CreateItemAtLocation( char.x, char.y, char.z, 0x1F03 );
  if ( !item )
    return ret_error( $"Could not create item: {item}" );
  endif

  item.movable := 1;

  var err;

  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( item );
    return err;
  endif

  if ( !drop_item_succeeded( err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial ) )
    DestroyItem( item );
    return err;
  endif

  DestroyItem( item );
  return 1;
endfunction

// 2. Move item from backpack to into backpack
exported function lift_backpack_drop_backpack()
  var item := CreateItemInBackpack( char, 0x1F03 );

  if ( !item )
    return ret_error( $"Could not create item: {item}" );
  endif

  item.movable := 1;

  var err;

  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( item );
    return err;
  endif

  if ( !drop_item_succeeded( err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial ) )
    DestroyItem( item );
    return err;
  endif

  DestroyItem( item );
  return 1;
endfunction

// 3. From item from backpack onto ground
exported function lift_backpack_drop_ground()
  var item := CreateItemInBackpack( char, 0x1F03 );

  if ( !item )
    return ret_error( $"Could not create item: {item}" );
  endif

  item.movable := 1;

  var err;

  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( item );
    return err;
  endif

  if ( !drop_item_succeeded( err, item.serial, char.x, char.y, char.z ) )
    DestroyItem( item );
    return err;
  endif

  DestroyItem( item );
  return 1;
endfunction

// 4. Attempt to move a no-drop item in a regular container fails and the item
//    goes back into its original container (versus the bug of the characters
//    backpack
exported function fail_lift_nodrop_drop_backpack()

  var nodrop_container := CreateItemAtLocation( char.x, char.y, char.z, 0xE75 );
  if ( !nodrop_container )
    return ret_error( $"Could not create nodrop_item: {nodrop_container}" );
  endif

  var nodrop_item := CreateItemInContainer( nodrop_container, 0x1F03 ); // robe
  if ( !nodrop_item )
    DestroyItem( nodrop_container );
    return ret_error( $"Could not create nodrop_item: {nodrop_item}" );
  endif

  nodrop_item.no_drop := 1;
  nodrop_item.movable := 1;
  char.backpack.no_drop_exception := 0;
  var x_before := nodrop_item.x;
  var y_before := nodrop_item.y;

  var err;

  if ( !lift_item_succeeded( err, nodrop_item.serial ) )
    DestroyItem( nodrop_container );
    return err;
  endif

  if ( !drop_item_failed( err, nodrop_item.serial, 0xFF, 0xFF, 0, char.backpack.serial ) )
    DestroyItem( nodrop_container );
    return err;
  endif

  if ( nodrop_item.container != nodrop_container )
    return ret_error( $"Incorrect container for nodrop_item, got {nodrop_item.container.serial:x} expected {nodrop_container.serial:x}" );
  endif

  if ( nodrop_item.x != x_before || nodrop_item.y != y_before )
    return ret_error( $"Position for nodrop_item inside nodrop_container changed, got {nodrop_item.x},{nodrop_item.y} expected {x_before.y_before}" );
  endif

  DestroyItem( nodrop_container );
  return 1;
endfunction

// 5. Take item from ground and try to put to container that is too far away.
// Item should be returned to the place where it has been taken.
exported function undo_drop_here_0_range_check_0()
  var err;
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create container into which we are going to drop
  var container := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !container )
    return ret_error( $"Could not create container: ${container}" );
  endif

  // create item near character
  var item := CreateItemAtLocation( char.x + 1, char.y, char.z, 0x0F3F );
  if ( !item )
    DestroyItem( container );
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;

  var prevItemX := item.x;
  var prevItemY := item.y;

  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    return err;
  endif
  // drop to container
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, container.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    return err;
  endif
  // container is too far item must be at previous location
  if ( item.x != prevItemX || item.y != prevItemY )
    DestroyItem( container );
    DestroyItem( item );
    return ret_error( $"Item should be returned to place where have taken it." );
  endif

  DestroyItem( container );
  DestroyItem( item );

  return 1;
endfunction

// 6. Take item from container and try to put to container that is too far away.
// Item should be placed at character backpack.
exported function undo_drop_0_range_0_container()
  var err;
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create container into which we are going to drop
  var container := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !container )
    return ret_error( $"Could not create container: ${container}" );
  endif
  SendViewContainer( char, container );

  // create item in container
  var item := CreateItemInContainer( container, 0x0F3F );
  if ( !item )
    DestroyItem( container );
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;
  // move character to accessible range
  res := MoveObjectToLocation( char, container.x, container.y, 0 );
  if ( !res )
    DestroyItem( container );
    DestroyItem( item );
    return ret_error( $"Could not move character: ${res}" );
  endif
  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    return err;
  endif
  // move character out of accessible range
  res := MoveObjectToLocation( char, charX, charY + 4, 0 );
  if ( !res )
    DestroyItem( container );
    DestroyItem( item );
    return ret_error( $"Could not move character: ${res}" );
  endif
  // drop item
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, container.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    return err;
  endif
  // container is too far, item must be at character backpack
  if ( !item.container || item.container.serial != char.backpack.serial )
    DestroyItem( container );
    DestroyItem( item );
    return ret_error( $"Item should be placed in character backpack." );
  endif

  DestroyItem( container );
  DestroyItem( item );

  return 1;
endfunction

// 7. Take NO DROP item from container and try to put to container that is too far away.
// Item is no_drop, so it should be placed original container.
exported function undo_drop_0_range_0_cont_ndrop()
  var err;
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create container into which we are going to drop item
  var containerTo := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !containerTo )
    return ret_error( $"Could not create container to: ${containerTo}" );
  endif

  // create container from which we are going to take item
  var containerFrom := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !containerFrom )
    DestroyItem( containerTo );
    return ret_error( $"Could not create container from: ${containerFrom}" );
  endif
  SendViewContainer( char, containerFrom );

  // create item in containerFrom
  var item := CreateItemInContainer( containerFrom, 0x0F3F );
  if ( !item )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;
  item.no_drop := 1;
  // move character to accessible range
  res := MoveObjectToLocation( char, containerFrom.x, containerFrom.y, 0 );
  if ( !res )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    DestroyItem( item );
    return ret_error( $"Could not move character: ${res}" );
  endif
  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    DestroyItem( item );
    return err;
  endif
  // move character out of accessible range
  res := MoveObjectToLocation( char, charX, charY + 4, 0 );
  if ( !res )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    DestroyItem( item );
    return ret_error( $"Could not move character: ${res}" );
  endif
  // drop item
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, containerTo.serial ) )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    DestroyItem( item );
    return err;
  endif
  // item is no_drop, item must be at character backpack
  if ( !item.container || item.container.serial != containerFrom.serial )
    DestroyItem( containerTo );
    DestroyItem( containerFrom );
    DestroyItem( item );
    return ret_error( $"Item should be returned in origin container." );
  endif

  DestroyItem( containerTo );
  DestroyItem( containerFrom );
  DestroyItem( item );

  return 1;
endfunction

// 8. Take item from ground and try to put to container that is too far away.
// Item should be placed at character feet.
exported function undo_range_check_1()
  var err;

  var originalConf := ReadFile( "::config/servspecopt.cfg" );
  if ( originalConf == error )
    return ret_error( $"Could not read config/servspecopt.cfg file: ${originalConf}" );
  endif

  var newConf := array;
  foreach line in originalConf
    if ( Find( line, "UndoGetItemEnableRangeCheck", 1 ) )
      continue;
    endif
    if ( Find( line, "DefaultAccessibleRange", 1 ) )
      continue;
    endif
    newConf.append( line );
  endforeach
  newConf.append( "DefaultAccessibleRange=2" );
  newConf.append( "UndoGetItemEnableRangeCheck=1" );

  var writeResult := WriteFile( "::config/servspecopt.cfg", newConf );
  if ( writeResult == error )
    return ret_error( $"Could not write config/servspecopt.cfg file: ${writeResult}" );
  endif

  ReloadConfiguration();

  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create container into which we are going to drop
  var container := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !container )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create container: ${container}" );
  endif

  // create item near the character
  var item := CreateItemAtLocation( char.x + 1, char.y, char.z, 0x0F3F );
  if ( !item )
    DestroyItem( container );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;
  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif
  // move character to not accessible range
  res := MoveObjectToLocation( char, charX - 2, charY, 0 );
  if ( !res )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not move character: ${res}" );
  endif
  // drop item
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, container.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif
  if ( item.x != char.x || item.y != char.y )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Item should be placed at character feet." );
  endif

  DestroyItem( container );
  DestroyItem( item );
  WriteFile( "::config/servspecopt.cfg", originalConf );
  ReloadConfiguration();

  return 1;
endfunction

// 9. Take item from ground and try to put to container that is too far away.
// Item should be placed at character feet.
exported function undo_drop_here_1()
  var err;

  var originalConf := ReadFile( "::config/servspecopt.cfg" );
  if ( originalConf == error )
    return ret_error( $"Could not read config/servspecopt.cfg file: ${originalConf}" );
  endif

  var newConf := array;
  foreach line in originalConf
    if ( Find( line, "UndoGetItemDropHere", 1 ) )
      continue;
    endif
    if ( Find( line, "DefaultAccessibleRange", 1 ) )
      continue;
    endif
    newConf.append( line );
  endforeach
  newConf.append( "DefaultAccessibleRange=2" );
  newConf.append( "UndoGetItemDropHere=1" );

  var writeResult := WriteFile( "::config/servspecopt.cfg", newConf );
  if ( writeResult == error )
    return ret_error( $"Could not write config/servspecopt.cfg file: ${writeResult}" );
  endif

  ReloadConfiguration();

  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create container into which we are going to drop
  var container := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !container )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create container: ${container}" );
  endif

  // create item near the character
  var item := CreateItemAtLocation( char.x + 1, char.y, char.z, 0x0F3F );
  if ( !item )
    DestroyItem( container );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;
  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif
  // drop item
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, container.serial ) )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif
  if ( item.x != char.x || item.y != char.y )
    DestroyItem( container );
    DestroyItem( item );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Item should be placed at character feet." );
  endif

  DestroyItem( container );
  DestroyItem( item );
  WriteFile( "::config/servspecopt.cfg", originalConf );
  ReloadConfiguration();

  return 1;
endfunction

// 10. Take item from a container in a container and try to put to container that is too far away.
// Backpack that is full, so item should be returned to original container.
exported function undo_range_check_1_ret_nested()
  var err;

  var originalConf := ReadFile( "::config/servspecopt.cfg" );
  if ( originalConf == error )
    return ret_error( $"Could not read config/servspecopt.cfg file: ${originalConf}" );
  endif

  var newConf := array;
  foreach line in originalConf
    if ( Find( line, "UndoGetItemEnableRangeCheck", 1 ) )
      continue;
    endif
    if ( Find( line, "DefaultAccessibleRange", 1 ) )
      continue;
    endif
    newConf.append( line );
  endforeach
  newConf.append( "DefaultAccessibleRange=2" );
  newConf.append( "UndoGetItemEnableRangeCheck=1" );

  var writeResult := WriteFile( "::config/servspecopt.cfg", newConf );
  if ( writeResult == error )
    return ret_error( $"Could not write config/servspecopt.cfg file: ${writeResult}" );
  endif

  ReloadConfiguration();

  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not move character: ${res}" );
  endif

  // create root container
  var rootContainer := CreateItemAtLocation( char.x, char.y, char.z, 0xE75 );
  if ( !rootContainer )
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create root container: ${rootContainer}" );
  endif
  SendViewContainer( char, rootContainer );

  // create container in root container from which we are going to take item
  var nestedContainer := CreateItemInContainer( rootContainer, 0xE75 );
  if ( !nestedContainer )
    DestroyItem( rootContainer );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create nested container: ${nestedContainer}" );
  endif
  SendViewContainer( char, nestedContainer );

  // create item in nested container
  var item := CreateItemInContainer( nestedContainer, 0x201f03 );
  if ( !item )
    DestroyItem( rootContainer );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create item: {item}" );
  endif
  item.movable := 1;

  var containerTo := CreateItemAtLocation( char.x + 4, char.y, char.z, 0xE75 );
  if ( !containerTo )
    DestroyItem( rootContainer );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create to container: ${containerTo}" );
  endif

  // create heavy item in backpack to make container full
  var backpackItem := CreateItemInContainer( char.backpack, 0x201f03 );
  if ( !backpackItem )
    DestroyItem( rootContainer );
    DestroyItem( containerTo );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Could not create backpack item: {backpackItem}" );
  endif

  // lift item
  if ( !lift_item_succeeded( err, item.serial ) )
    DestroyItem( rootContainer );
    DestroyItem( containerTo );
    DestroyItem( backpackItem );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif
  // drop item
  if ( !drop_item_failed( err, item.serial, 0xFF, 0xFF, 0, containerTo.serial ) )
    DestroyItem( rootContainer );
    DestroyItem( containerTo );
    DestroyItem( backpackItem );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return err;
  endif

  if ( !item.container || item.container.serial != nestedContainer.serial )
    DestroyItem( rootContainer );
    DestroyItem( containerTo );
    DestroyItem( backpackItem );
    WriteFile( "::config/servspecopt.cfg", originalConf );
    ReloadConfiguration();
    return ret_error( $"Item should be returned in original container." );
  endif

  DestroyItem( rootContainer );
  DestroyItem( containerTo );
  DestroyItem( backpackItem );
  WriteFile( "::config/servspecopt.cfg", originalConf );
  ReloadConfiguration();

  return 1;
endfunction

// Switching realms while holding an item should update the item's (and contents') realm.
exported function realm_switch_drop_item_success( resources )
  return realm_switch_delete_realm_drop_test_helper( resources, false );
endfunction

// Dropping an item too far away that was picked up in another realm should return the item to its original realm.
exported function realm_switch_drop_item_fail_1( resources )
  var res;
  var realm := char.realm;
  var shadow_realm := $"shadow-{realm}";

  res := resources.AddRealm( shadow_realm, realm );
  if ( !res )
    return ret_error( $"Error creating realm: {res}" );
  endif

  var test_func := @() {
    // Create container in base realm
    var container := resources.CreateItemAtLocation( char.x, char.y, char.z, "backpack",
                                                     1, char.realm );
    if ( !container )
      return ret_error( $"Error creating container in shadow realm: {container}" );
    endif

    // Create content item inside container
    var content := CreateItemInContainer( container, 0xeed );
    if ( !content )
      return ret_error( $"Error creating content in container: {content}" );
    endif

    // Pick up container
    if ( !lift_item_succeeded( res, container.serial ) )
      return res;
    endif

    // Check gotten item
    if ( char.getgottenitem() != container )
      return ret_error( $"char.gottenitem is not the container: expected {container.serial} got {char.getgottenitem().serial
                        ?: char.getgottenitem()}" );
    endif

    // Check container realm
    if ( container.realm != realm )
      return ret_error( $"Incorrect container.realm: expected {realm} got {container.realm}" );
    endif

    // Check container contents realm
    if ( content.realm != realm )
      return ret_error( $"Incorrect content.realm: expected {realm} got {container.realm}" );
    endif

    // Move character to shadow realm
    res := MoveObjectToLocation( char, charX, charY, 0, shadow_realm );
    if ( !res )
      return ret_error( $"Error moving character to shadow realm: {res}" );
    endif

    // Verify character realm is shadow realm
    if ( char.realm != shadow_realm )
      return ret_error( $"Incorrect char.realm: expected {shadow_realm} got {char.realm}" );
    endif

    // Drop item on ground too far away
    if ( !drop_item_failed( res, container.serial, char.x + 5, char.y + 5, char.z ) )
      return res;
    endif

    // Check container realm (undo sends back to base realm)
    if ( container.realm != realm )
      return ret_error( $"Incorrect container.realm: expected {realm} got {container.realm}" );
    endif

    // Check container contents realm (undo sends back to base realm)
    if ( content.realm != realm )
      return ret_error( $"Incorrect content.realm: expected {realm} got {container.realm}" );
    endif

    // Character should not see item
    clientcon.sendevent( struct{ todo := "list_objects", id := 0 } );
    res := waitForClient( 0, { EVT_LIST_OBJS } );
    if ( !res )
      return res;
    endif
    foreach it in ( res["objs"] )
      if ( it["serial"] == container.serial )
        return ret_error( "Container still in range" );
      endif
    endforeach

    // Move back to britannia
    res := MoveObjectToLocation( char, charX, charY, 0, realm );
    if ( !res )
      return ret_error( $"Error moving character to back to base realm: {res}" );
    endif

    return 1;
  };

  res := test_func();

  // Move character back to britannia if test fails so realm can be destroyed by
  // resource manager.
  if ( !res )
    MoveObjectToLocation( char, charX, charY, 0, realm );
  endif

  return res;
endfunction

// Dropping an item in an incorrect place, after moving to different realm and
// destroying source realm: undo should drop item to character's feet and not
// attempt to place it in the (now-deleted) shadow realm.
exported function realm_switch_drop_item_fail_2( resources )
  return realm_switch_delete_realm_drop_test_helper( resources, true );
endfunction

// Equipping an item with EquipItem on an NPC and destroying it with DestroyItem will
// trigger the equiptest/equip and unequiptest/unequip scripts with both on_chr
// and by_chr as the NPC.
exported function test_equip_npc_equipitem( resources )
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return res;
  endif

  var npc := resources.CreateNPCFromTemplate( ":testnpc:probe_npc", char.x, char.y, char.z );
  if ( !npc )
    return npc;
  endif

  var backpack := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, 0xE75 );
  if ( !backpack )
    return backpack;
  endif

  res := EquipItem( npc, backpack );
  if ( !res )
    return res;
  endif

  var shirt := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, "shirt_events" );
  if ( !shirt )
    return shirt;
  endif

  SetObjProperty( shirt, "#TestPid", GetPid() );

  Clear_Event_Queue();
  res := EquipItem( npc, shirt );
  if ( !res )
    return res;
  endif

  var evs := get_events();
  if ( !evs )
    return evs;
  endif
  res := validate_events( evs, npc, npc, shirt, false );
  if ( !res )
    return res;
  endif

  Clear_Event_Queue();
  res := DestroyItem( shirt );
  if ( !res )
    return res;
  endif

  evs := get_events();
  if ( !evs )
    return evs;
  endif
  res := validate_events( evs, npc, npc, shirt, true );
  if ( !res )
    return res;
  endif

  return 1;
endfunction

// When an NPC's master equips an item on the NPC, on_chr will be the NPC and
// by_chr will be the player.
exported function test_equip_npc_dragdrop( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanClotheNPCs := 1 } );
  if ( !res )
    return res;
  endif

  res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return res;
  endif

  var npc := resources.CreateNPCFromTemplate( ":testnpc:probe_npc", char.x, char.y, char.z );
  if ( !npc )
    return npc;
  endif

  npc.setmaster( char );

  var backpack := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, 0xE75 );
  if ( !backpack )
    return backpack;
  endif

  res := EquipItem( npc, backpack );
  if ( !res )
    return res;
  endif

  var shirt := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, "shirt_events" );
  if ( !shirt )
    return shirt;
  endif

  SetObjProperty( shirt, "#TestPid", GetPid() );

  if ( !lift_item_succeeded( res, shirt.serial ) )
    return res;
  endif

  var equipscript_testfunc := @() {
    // Get three events, and check for wear_item and equiptest & equip
    var evs := get_events( 1, 3 );
    if ( !evs )
      return evs;
    endif

    var found_wear_item := false;

    evs := evs.filter( @( ev ) {
      if ( ev.type == EVT_WEAR_ITEM )
        found_wear_item := true;
        return false;
      endif

      return true;
    } );

    if ( !found_wear_item )
      return ret_error( "No wear_item event received" );
    endif

    res := validate_events( evs, npc, char, shirt, false );
    if ( !res )
      return res;
    endif

    return 1;
  };

  if ( !wear_item_succeeded( res, shirt.serial, LAYER_SHIRT, npc.serial, equipscript_testfunc ) )
    return res;
  endif

  if ( !lift_item_succeeded( res, shirt.serial ) )
    return res;
  endif

  if ( !drop_item_succeeded( res, shirt.serial, char.x, char.y, char.z ) )
    return res;
  endif

  return 1;
endfunction

// When an NPC's non-master equips an item on the NPC, the equip should fail.
exported function test_equip_npc_dragdrop_fail_1( resources )
  return equip_npc_dragdrop_fail_helper( resources, FAIL_REASON_NOT_MASTER );
endfunction

// When an NPC's master equips an item on the NPC but servspecopt does not allow
// masters to equip NPCs, the equip should fail.
exported function test_equip_npc_dragdrop_fail_2( resources )
  return equip_npc_dragdrop_fail_helper( resources, FAIL_REASON_CONFIG_NOT_ALLOWED );
endfunction

// An NPC's master *cannot* take things from NPC backpack based off MasterCanClotheNPCs=1
exported function master_remove_from_npc_pack_fail( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanClotheNPCs := 1 } );
  if ( !res )
    return res;
  endif

  var item := create_item_in_npc_pack_helper( resources );
  if ( !item )
    return item;
  endif

  if ( lift_item_succeeded( res, item.serial ) )
    return ret_error( "Unexpected success for lift_item" );
  endif

  return 1;
endfunction

// An NPC's master *can* take things from NPC backpack based off MasterCanAccessNPCsBackpack=1
exported function master_remove_from_npc_pack_ok( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanAccessNPCsBackpack := 1 } );
  if ( !res )
    return res;
  endif

  var item := create_item_in_npc_pack_helper( resources );
  if ( !item )
    return item;
  endif

  if ( !lift_item_succeeded( res, item.serial ) )
    return res;
  endif

  if ( !drop_item_succeeded( res, item.serial, char.x, char.y, char.z ) )
    return res;
  endif

  return 1;
endfunction

// Dropping directly onto NPC's backpack fails without MasterCanAccessNPCsBackpack=1
exported function master_add_to_npc_pack_fail( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanClotheNPCs := 1 } );
  if ( !res )
    return res;
  endif

  var item := create_item_in_npc_pack_helper( resources );
  if ( !item )
    return item;
  endif

  var backpack := item.character_owner.backpack;

  var item_to_add := resources.CreateItemAtLocation( char.x, char.y, char.z, 0xeed, 1, char.realm );

  if ( !lift_item_succeeded( res, item_to_add.serial ) )
    return res;
  endif

  if ( !drop_item_failed( res, item_to_add.serial, -1, -1, -1, backpack.serial ) )
    return res;
  endif

  return 1;
endfunction

// Dropping directly onto NPC's backpack succeeds with MasterCanAccessNPCsBackpack=1
exported function master_add_to_npc_pack_ok( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanAccessNPCsBackpack := 1 } );
  if ( !res )
    return res;
  endif

  var item := create_item_in_npc_pack_helper( resources );
  if ( !item )
    return item;
  endif

  var backpack := item.character_owner.backpack;

  var item_to_add := resources.CreateItemAtLocation( char.x, char.y, char.z, 0xeed, 1, char.realm );

  if ( !lift_item_succeeded( res, item_to_add.serial ) )
    return res;
  endif

  if ( !drop_item_succeeded( res, item_to_add.serial, -1, -1, -1, backpack.serial ) )
    return res;
  endif

  return 1;
endfunction

// Dropping directly onto NPC's backpack succeeds with MasterCanAccessNPCsBackpack=1
exported function master_add_to_npc_pack_cont_ok( resources )
  var res := resources.UpdateConfiguration( struct{ MasterCanAccessNPCsBackpack := 1 } );
  if ( !res )
    return res;
  endif

  var item := create_item_in_npc_pack_helper( resources, 0xE75 );
  if ( !item )
    return item;
  endif

  var backpack := item.character_owner.backpack;

  var item_to_add := resources.CreateItemAtLocation( char.x, char.y, char.z, 0xeed, 1, char.realm );

  if ( !lift_item_succeeded( res, item_to_add.serial ) )
    return res;
  endif

  if ( !drop_item_succeeded( res, item_to_add.serial, -1, -1, -1, backpack.serial ) )
    return res;
  endif

  return 1;
endfunction

/**
 * Helper functions
 */
// Checks equiptest & equip or unequiptest & unequip events have expected values
function validate_events( evs, on_chr, by_chr, item, is_unequip )
  if ( evs.size() != 2 )
    return ret_error( $"Incorrect events array size, expected 2 got {evs.size()}" );
  endif
  foreach ev in evs
    var type := _ev_iter == 1 ? ( is_unequip ? "unequiptest" : "equiptest" ) : ( is_unequip ? "unequip" :
                                                                                 "equip" );

    if ( ev.on_chr != on_chr || ev.by_chr != by_chr || ev.item != item || ev.type != type )
      return ret_error( $"Unexpected event #{_ev_iter}: ev.on_chr ({ev.on_chr.name}) != on_chr ({on_chr.name}) || ev.by_chr ({ev.by_chr.name}) != by_chr ({by_chr.name}) || ev.item ({ev.item.name}) != item ({item.name}) || ev.type ({ev.type}) != type ({type})" );
    endif
  endforeach
  return 1;
endfunction

// Returns two events as an array, eg. equiptest & equip or unequiptest & unequip events
function get_events( timeout := 0, count := 2 )
  var evs := {};

  while ( count-- > 0 )
    var res := wait_for_event( timeout );
    if ( !res )
      return ret_error( "No event received" );
    endif
    evs.append( res );
  endwhile
  return evs;
endfunction

// Create an NPC, setting its master to `char`, and return a newly-created item
// within the NPC's backpack.
function create_item_in_npc_pack_helper( resources, objtype := 0xeed )
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return res;
  endif

  var npc := resources.CreateNPCFromTemplate( ":testnpc:probe_npc", char.x, char.y, char.z );
  if ( !npc )
    return npc;
  endif

  npc.setmaster( char );

  var backpack := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, 0xE75 );
  if ( !backpack )
    return backpack;
  endif

  res := EquipItem( npc, backpack );
  if ( !res )
    return res;
  endif

  var item := CreateItemInContainer( backpack, objtype, 1 );

  return item;
endfunction

enum EquipNpcDragdropFailReason
  // When MasterCanClotheNPCs=1 but char is not NPC's master
  FAIL_REASON_NOT_MASTER,

  // When MasterCanClotheNPCs=0 but char is NPC's master
  FAIL_REASON_CONFIG_NOT_ALLOWED
endenum

function equip_npc_dragdrop_fail_helper( resources, fail_reason )
  var res := MoveObjectToLocation( char, charX, charY, 0 );
  if ( !res )
    return res;
  endif

  var npc := resources.CreateNPCFromTemplate( ":testnpc:probe_npc", char.x, char.y, char.z );
  if ( !npc )
    return npc;
  endif

  var backpack := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, 0xE75 );
  if ( !backpack )
    return backpack;
  endif

  res := EquipItem( npc, backpack );
  if ( !res )
    return res;
  endif

  var shirt := resources.CreateItemAtLocation( npc.x, npc.y, npc.z, "shirt_events" );
  if ( !shirt )
    return shirt;
  endif

  SetObjProperty( shirt, "#TestPid", GetPid() );

  if ( !lift_item_succeeded( res, shirt.serial ) )
    return res;
  endif

  if ( fail_reason == FAIL_REASON_NOT_MASTER )
    // Set MasterCanClotheNPCs but do not set NPC's master
    res := resources.UpdateConfiguration( struct{ MasterCanClotheNPCs := 1 } );
    if ( !res )
      return res;
    endif
  elseif ( fail_reason == FAIL_REASON_CONFIG_NOT_ALLOWED )
    // The default configuration has MasterCanClotheNPCs=0, so only set NPC's master
    npc.setmaster( char );
  endif

  if ( !wear_item_failed( res, shirt.serial, LAYER_SHIRT, npc.serial ) )
    return res;
  endif

  return 1;
endfunction

function realm_switch_delete_realm_drop_test_helper( resources, should_drop_too_far_away )
  var res;
  var realm := char.realm;
  var shadow_realm := $"shadow-{realm}";

  res := resources.AddRealm( shadow_realm, realm );
  if ( !res )
    return ret_error( $"Error creating realm: {res}" );
  endif

  var test_func := @() {
    // Move character to shadow realm
    res := MoveObjectToLocation( char, charX, charY, 0, shadow_realm );
    if ( !res )
      return ret_error( $"Error moving character to shadow realm: {res}" );
    endif

    // Verify character realm is shadow realm
    if ( char.realm != shadow_realm )
      return ret_error( $"Incorrect char.realm: expected {shadow_realm} got {char.realm}" );
    endif

    // Create container in shadow realm
    var container := resources.CreateItemAtLocation( char.x, char.y, char.z, "backpack",
                                                     1, shadow_realm );
    if ( !container )
      return ret_error( $"Error creating container in shadow realm: {container}" );
    endif

    // Create content item inside container
    var content := CreateItemInContainer( container, 0xeed );
    if ( !content )
      return ret_error( $"Error creating content in container: {content}" );
    endif

    // Pick up container
    if ( !lift_item_succeeded( res, container.serial ) )
      return res;
    endif

    // Check gotten item
    if ( char.getgottenitem() != container )
      return ret_error( $"char.gottenitem is not the container: expected {container.serial} got {char.getgottenitem().serial
                        ?: char.getgottenitem()}" );
    endif

    // Check container realm
    if ( container.realm != shadow_realm )
      return ret_error( $"Incorrect container.realm: expected {shadow_realm} got {container.realm}" );
    endif

    // Check container contents realm
    if ( content.realm != shadow_realm )
      return ret_error( $"Incorrect content.realm: expected {shadow_realm} got {container.realm}" );
    endif

    // Move back to britannia
    res := MoveObjectToLocation( char, charX, charY, 0, realm );
    if ( !res )
      return ret_error( $"Error moving character to back to base realm: {res}" );
    endif

    // Delete shadow realm
    res := DeleteRealm( shadow_realm );
    if ( !res )
      return ret_error( $"Error deleting shadow realm: {res}" );
    endif

    // Drop item on ground at feet
    if ( should_drop_too_far_away )
      if ( !drop_item_failed( res, container.serial, char.x + 5, char.y + 5, char.z ) )
        return res;
      endif
    else
      if ( !drop_item_succeeded( res, container.serial, char.x, char.y, char.z ) )
        return res;
      endif
    endif

    // Check container realm
    if ( container.realm != realm )
      return ret_error( $"Incorrect container.realm: expected {realm} got {container.realm}" );
    endif

    // Check container contents realm
    if ( content.realm != realm )
      return ret_error( $"Incorrect content.realm: expected {realm} got {container.realm}" );
    endif

    return 1;
  };

  res := test_func();

  // Move character back to britannia if test fails so realm can be destroyed by
  // resource manager.
  if ( !res )
    MoveObjectToLocation( char, charX, charY, 0, realm );
  endif

  return res;
endfunction

function drop_item_failed( byref err, serial, x, y, z, dropped_on_serial := 0xFFFFFFFF )
  Clear_Event_Queue();
  clientcon.sendevent( struct{ todo := "drop_item",
                               arg := struct{ serial := serial, x := x, y := y,
                                              z := z, dropped_on_serial := dropped_on_serial },
                               id := 0 } );
  var ev;
  while ( 1 )
    ev := waitForClient( 0, { EVT_DROP_ITEM } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile

  while ( 1 )
    ev := waitForClient( 0, { EVT_MOVE_ITEM_REJECTED } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile
  return 1;
endfunction

function drop_item_succeeded( byref err, serial, x, y, z, dropped_on_serial := 0xFFFFFFFF )
  Clear_Event_Queue();
  clientcon.sendevent( struct{ todo := "drop_item",
                               arg := struct{ serial := serial, x := x, y := y,
                                              z := z, dropped_on_serial := dropped_on_serial },
                               id := 0 } );
  var ev;
  while ( 1 )
    ev := waitForClient( 0, { EVT_DROP_ITEM } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile

  while ( 1 )
    ev := waitForClient( 0, { EVT_DROP_APPROVED } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile
  return 1;
endfunction

function wear_item_succeeded( byref err, item_serial, layer, player_serial, equipscript_testfunc )
  Clear_Event_Queue();
  clientcon.sendevent( struct{ todo := "wear_item",
                               arg := struct{ item_serial := item_serial,
                                              layer := layer, player_serial := player_serial },
                               id := 0 } );

  if ( !( err := equipscript_testfunc() ) )
    return err;
  endif

  clientcon.sendevent( struct{ todo := "list_equipped_items", arg := player_serial, id := 0 } );
  var ev := waitForClient( 0, { EVT_LIST_EQUIPPED_ITEMS } );
  if ( !ev )
    return ev;
  endif

  if ( !ev.objs.find( @( equipped_item ) {
    return equipped_item.serial == item_serial;
  } ) )
    return ret_error( $"Item 0x{item_serial:x} not listed in equipment for player serial 0x{player_serial:x}" );
  endif

  return 1;
endfunction

function wear_item_failed( byref err, item_serial, layer, player_serial )
  Clear_Event_Queue();
  clientcon.sendevent( struct{ todo := "wear_item",
                               arg := struct{ item_serial := item_serial,
                                              layer := layer, player_serial := player_serial },
                               id := 0 } );

  var ev;
  while ( 1 )
    ev := waitForClient( 0, { EVT_WEAR_ITEM } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile

  while ( 1 )
    ev := waitForClient( 0, { EVT_MOVE_ITEM_REJECTED } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile
  return 1;
endfunction

function lift_item_succeeded( byref err, serial )
  Clear_Event_Queue();
  clientcon.sendevent( struct{ todo := "lift_item", arg := serial, id := 0 } );
  var ev;
  while ( 1 )
    ev := waitForClient( 0, { EVT_LIFT_ITEM } );
    if ( !ev )
      return err := ev;
    endif
    break;
  endwhile

  // TODO: see top
  ev := waitForClient( 0, { EVT_MOVE_ITEM_REJECTED }, 1 );
  if ( ev )
    return err := ret_error( $"Got unexpected move (lift) item rejected: reason = {ev.reason}" );
  endif
  return 1;
endfunction
