include "communication";
include "testutil";

use os;
use uo;
use boat;

var char;
var charX := 1478;
var charY := 1706;
var clientcon := getClientConnection();

program test_item_move()
  var a:=FindAccount("testclient0");
  char:=a.getcharacter(1);
  if (!char)
    return ret_error("Could not find char at slot 1");
  endif

  // Move character somewhere nice.
  var res := MoveObjectToLocation(char, 100, 50, 0);
  if (!res)
    return ret_error($"Could not move character: ${res}");
  endif

  return 1;
endprogram

/**
 * Tests
 */

// 1. Move item from ground into backpack
exported function lift_ground_drop_backpack()
  var item := CreateItemAtLocation(char.x, char.y, char.z, 0x1F03);
  if (!item)
    return ret_error($"Could not create item: {item}");
  endif

  item.movable := 1;

  var err;

  if (!lift_item_succeeded(err, item.serial))
    DestroyItem(item);
    return err;
  endif

  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    DestroyItem(item);
    return err;
  endif

  DestroyItem(item);
  return 1;
endfunction

// 2. Move item from backpack to into backpack
exported function lift_backpack_drop_backpack()
  var item := CreateItemInBackpack(char, 0x1F03);

  if (!item)
    return ret_error($"Could not create item: {item}");
  endif

  item.movable := 1;

  var err;

  if (!lift_item_succeeded(err, item.serial))
    DestroyItem(item);
    return err;
  endif

  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    DestroyItem(item);
    return err;
  endif

  DestroyItem(item);
  return 1;
endfunction

// 3. From item from backpack onto ground
exported function lift_backpack_drop_ground()
  var item := CreateItemInBackpack(char, 0x1F03);

  if (!item)
    return ret_error($"Could not create item: {item}");
  endif

  item.movable := 1;

  var err;

  if (!lift_item_succeeded(err, item.serial))
    DestroyItem(item);
    return err;
  endif

  if (!drop_item_succeeded(err, item.serial, char.x, char.y, char.z))
    DestroyItem(item);
    return err;
  endif

  DestroyItem(item);
  return 1;
endfunction

// 4. Attempt to move a no-drop item in a regular container fails and the item
//    goes back into its original container (versus the bug of the characters
//    backpack
exported function fail_lift_nodrop_drop_backpack()

  var nodrop_container := CreateItemAtLocation(char.x, char.y, char.z, 0xE75);
  if (!nodrop_container)
    return ret_error($"Could not create nodrop_item: {nodrop_container}");
  endif

  var nodrop_item := CreateItemInContainer(nodrop_container, 0x1F03); // robe
  if (!nodrop_item)
    DestroyItem(nodrop_container);
    return ret_error($"Could not create nodrop_item: {nodrop_item}");
  endif

  nodrop_item.no_drop := 1;
  nodrop_item.movable := 1;
  char.backpack.no_drop_exception := 0;
  var x_before := nodrop_item.x;
  var y_before := nodrop_item.y;

  var err;

  if (!lift_item_succeeded(err, nodrop_item.serial))
    DestroyItem(nodrop_container);
    return err;
  endif

  if (!drop_item_failed(err, nodrop_item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    DestroyItem(nodrop_container);
    return err;
  endif

  if (nodrop_item.container != nodrop_container)
    return ret_error($"Incorrect container for nodrop_item, got {nodrop_item.container.serial:x} expected {nodrop_container.serial:x}");
  endif

  if (nodrop_item.x != x_before || nodrop_item.y != y_before)
    return ret_error($"Position for nodrop_item inside nodrop_container changed, got {nodrop_item.x},{nodrop_item.y} expected {x_before.y_before}");
  endif

  DestroyItem(nodrop_container);
  return 1;
endfunction


// 5. ssopt: undo_get_item_drop_here and undo_get_item_enable_range_check
exported function ssopt_item_drop_here_range_check()
  //move character to britain?
  var res := MoveObjectToLocation(char, charX, charY, GetWorldHeight(charX, charY));
  if (!res)
    return ret_error($"Could not move character: ${res}");
  endif

  //fill backpack with arrows
  var item;
  var filled := 0;
  var items := array;
  var i := 0;
  var errortext;
  while(i < 1000000)
    item := CreateItemInContainer(char.backpack, 0x0F3F);
    if(item == error)
        if(item.errortext == "That container is full")
            filled := 1;
        endif
        errortext := error.errortext;
        break;
    endif
    item.movable := 1;
    items.append(item);
    i := i + 1;
  endwhile

  if(!filled)
    destroy_items(items);
    return ret_error($"Could not fill backpack with items: ${errortext}");
  endif

  //create item at character feet
  item := CreateItemAtLocation(char.x, char.y, char.z, 0x0F3F);
  if(!item)
    destroy_items(items);
    return ret_error($"Could not create item: {item}");
  endif

  /*
  var prevItemX := item.x;
  var prevItemY := item.y;

  //undo_get_item_drop_here = 0
  //lift item
  var err;
  if (!lift_item_succeeded(err, item.serial))
    destroy_items(items, item);
    return err;
  endif
  //move character one tile
  res := MoveObjectToLocation(char, charX + 1, charY, GetWorldHeight(charX + 1, charY));
  if (!res)
    destroy_items(items);
    return ret_error($"Could not move character: ${res}");
  endif
  //drop to backpack
  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    destroy_items(items, item);
    return err;
  endif
  //item must be at previous location
  if(item.x != prevItemX || item.y != prevItemY)
    destroy_items(items, item);
    return ret_error($"Item should be returned to place where we've got it, but it failed to appear there.");
  endif
  */

  //TODO: change undo_get_item_drop_here = 1
  //lift item
  /*
  if (!lift_item_succeeded(err, item.serial))
    destroy_items(items, item);
    return err;
  endif
  res := MoveObjectToLocation(char, charX, charY, GetWorldHeight(charX, charY));
  if (!res)
    destroy_items(items);
    return ret_error($"Could not move character: ${res}");
  endif
  //drop to backpack
  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    destroy_items(items, item);
    return err;
  endif
  //item must be at character feet
  if(item.x != char.x || item.y != char.y)
    destroy_items(items, item);
    return ret_error($"Item should be at character feet, but it failed to appear there.");
  endif
  */

  //TODO: should be changed above undo_get_item_drop_here = 1
  //undo_get_item_enable_range_check = 0 && undo_get_item_drop_here = 1
  /*
  prevItemX := item.x;
  prevItemY := item.y;
  //lift item
  if (!lift_item_succeeded(err, item.serial))
    destroy_items(items, item);
    return err;
  endif
  //move character out of accessible range
  res := MoveObjectToLocation(char, charX + 4, charY, GetWorldHeight(charX + 4, charY));
  if (!res)
    destroy_items(items);
    return ret_error($"Could not move character: ${res}");
  endif
  //drop item
  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    destroy_items(items, item);
    return err;
  endif
  if(item.x != char.x || item.y != char.y)
    destroy_items(items, item);
    return ret_error($"Item should be at character feet, but it failed to appear there.");
  endif
  */

  //TODO: change undo_get_item_enable_range_check = 1 && undo_get_item_drop_here = 1
  /*
  prevItemX := item.x;
  prevItemY := item.y;
  //lift item
  if (!lift_item_succeeded(err, item.serial))
    destroy_items(items, item);
    return err;
  endif
  //move character out of accessible range
  res := MoveObjectToLocation(char, charX, charY, GetWorldHeight(charX, charY));
  if (!res)
    destroy_items(items);
    return ret_error($"Could not move character: ${res}");
  endif
  //drop item
  if (!drop_item_succeeded(err, item.serial, 0xFF, 0xFF, 0, char.backpack.serial))
    destroy_items(items, item);
    return err;
  endif
  if(item.x != prevItemX || item.y != prevItemY)
    destroy_items(items, item);
    return ret_error($"Item should be returned to place where we've got it, but it failed to appear there.");
  endif
  */

  destroy_items(items, item);
  return 1;
endfunction

/**
 * Helper functions
 */

function drop_item_failed(byref err, serial, x, y, z, dropped_on_serial := 0xFFFFFFFF)
  Clear_Event_Queue();
  clientcon.sendevent(struct{todo:="drop_item", arg:=struct{serial := serial, x := x, y := y, z := z, dropped_on_serial := dropped_on_serial}, id:=0});
  var ev;
  while (1)
    ev:=waitForClient(0, {EVT_DROP_ITEM});
    if (!ev)
      return err := ev;
    endif
    break;
  endwhile

  while (1)
    ev:=waitForClient(0, {EVT_MOVE_ITEM_REJECTED});
    if (!ev)
      return err := ev;
    endif
    break;
  endwhile
  return 1;
endfunction

function drop_item_succeeded(byref err, serial, x, y, z, dropped_on_serial := 0xFFFFFFFF)
  Clear_Event_Queue();
  clientcon.sendevent(struct{todo:="drop_item", arg:=struct{serial := serial, x := x, y := y, z := z, dropped_on_serial := dropped_on_serial}, id:=0});
  var ev;
  while (1)
    ev:=waitForClient(0, {EVT_DROP_ITEM});
    if (!ev)
      return err := ev;
    endif
    break;
  endwhile

  while (1)
    ev:=waitForClient(0, {EVT_DROP_APPROVED});
    if (!ev)
      return err := ev;
    endif
    break;
  endwhile
  return 1;
endfunction

function lift_item_succeeded(byref err, serial)
  Clear_Event_Queue();
  clientcon.sendevent(struct{todo:="lift_item", arg:=serial, id:=0});
  var ev;
  while (1)
    ev:=waitForClient(0, {EVT_LIFT_ITEM});
    if (!ev)
      return err := ev;
    endif
    break;
  endwhile
  return 1;

  ev:=waitForClient(0, {EVT_MOVE_ITEM_REJECTED}, 1);
  if (ev)
    return err := ret_error($"Got unexpected move (lift) item rejected: reason = {ev.reason}");;
  endif
  return 1;
endfunction

function destroy_items(items, oneitem := 0)
  if(oneitem)
    DestroyItem(oneitem);
  endif
  foreach item in items
    DestroyItem(item);
  endforeach
endfunction
